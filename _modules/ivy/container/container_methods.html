<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ivy.container.container_methods &mdash; Ivy 1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="icon" type="image/png" href="https://github.com/unifyai/unifyai.github.io/blob/master/img/externally_linked/ivy_logo_only.png?raw=true">
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Ivy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../background.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extensions.html">Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deep_dive.html">Deep Dive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Array</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../array/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/array.html">Array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/array_methods.html">Array methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/conversions.html">Conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/creation.html">Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/data_type.html">Data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/elementwise.html">Elementwise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/general.html">General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/gradients.html">Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/linear_algebra.html">Linear algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/losses.html">Losses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/manipulation.html">Manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/random.html">Random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/searching.html">Searching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/sorting.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/statistical.html">Statistical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/utility.html">Utility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../array/wrapping.html">Wrapping</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Container</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../container/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/base.html">Base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/container.html">Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/container_methods.html">Container methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/conversions.html">Conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/creation.html">Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/data_type.html">Data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/elementwise.html">Elementwise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/general.html">General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/gradients.html">Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/linear_algebra.html">Linear algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/losses.html">Losses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/manipulation.html">Manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/random.html">Random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/searching.html">Searching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/sorting.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/statistical.html">Statistical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/utility.html">Utility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../container/wrapping.html">Wrapping</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/compilation.html">Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/constants.html">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/creation.html">Creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/data_type.html">Data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/device.html">Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/elementwise.html">Elementwise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/extensions.html">Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/general.html">General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/gradients.html">Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/linear_algebra.html">Linear algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/losses.html">Losses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/manipulation.html">Manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/meta.html">Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/nest.html">Nest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/random.html">Random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/searching.html">Searching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/sorting.html">Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/statistical.html">Statistical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../functional/ivy/utility.html">Utility</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Stateful</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/activations.html">Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/converters.html">Converters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/initializers.html">Initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/layers.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/module.html">Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/norms.html">Norms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/optimizers.html">Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../stateful/sequential.html">Sequential</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ivy"">Ivy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mech"">Ivy mech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../vision"">Ivy vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../robot"">Ivy robot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gym"">Ivy gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../memory"">Ivy memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../builder"">Ivy builder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models"">Ivy models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ecosystem"">Ivy ecosystem</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ivy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>ivy.container.container_methods</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ivy.container.container_methods</h1><div class="highlight"><pre>
<span></span><span class="c1">#ivy.container.activations</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>


<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_relu"><a class="viewcode-back" href="../../../container/container_methods/static_relu.html#ivy.container.container_methods.static_relu">[docs]</a><span class="k">def</span> <span class="nf">static_relu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the rectified linear activation unit function</span>
<span class="sd">        applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 0, 1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_relu(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 0., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="relu"><a class="viewcode-back" href="../../../container/container_methods/relu.html#ivy.container.container_methods.relu">[docs]</a><span class="k">def</span> <span class="nf">relu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the rectified linear activation unit function</span>
<span class="sd">        applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 0, 1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 0., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_leaky_relu"><a class="viewcode-back" href="../../../container/container_methods/static_leaky_relu.html#ivy.container.container_methods.static_leaky_relu">[docs]</a><span class="k">def</span> <span class="nf">static_leaky_relu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.leaky_relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.leaky_relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    alpha</span>
<span class="sd">        array or scalar specifying the negative slope.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">         a container with the leaky relu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.39, -0.85]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_leaky_relu(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">          a: ivy.array([0.39, -0.17])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="leaky_relu"><a class="viewcode-back" href="../../../container/container_methods/leaky_relu.html#ivy.container.container_methods.leaky_relu">[docs]</a><span class="k">def</span> <span class="nf">leaky_relu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.leaky_relu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.leaky_relu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    alpha</span>
<span class="sd">        array or scalar specifying the negative slope.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">       a container with the leaky relu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.39, -0.85]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.leaky_relu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.39, -0.17])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_gelu"><a class="viewcode-back" href="../../../container/container_methods/static_gelu.html#ivy.container.container_methods.static_gelu">[docs]</a><span class="k">def</span> <span class="nf">static_gelu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">approximate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.gelu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.gelu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    approximate</span>
<span class="sd">        whether to use the gelu approximation algorithm or exact formulation.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the gelu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.3, -0.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_gelu(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.185, -0.046])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gelu"><a class="viewcode-back" href="../../../container/container_methods/gelu.html#ivy.container.container_methods.gelu">[docs]</a><span class="k">def</span> <span class="nf">gelu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">approximate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gelu.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.gelu also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    approximate</span>
<span class="sd">        whether to use the gelu approximation algorithm or exact formulation.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the gelu unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a =ivy.array([0.3, -0.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.gelu()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.185, -0.046])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_sigmoid"><a class="viewcode-back" href="../../../container/container_methods/static_sigmoid.html#ivy.container.container_methods.static_sigmoid">[docs]</a><span class="k">def</span> <span class="nf">static_sigmoid</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sigmoid.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.sigmoid also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the sigmoid unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., 1., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sigmoid(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.269, 0.731, 0.881])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sigmoid"><a class="viewcode-back" href="../../../container/container_methods/sigmoid.html#ivy.container.container_methods.sigmoid">[docs]</a><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sigmoid.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.sigmoid also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the sigmoid unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., 1., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sigmoid()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.269, 0.731, 0.881])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_softmax"><a class="viewcode-back" href="../../../container/container_methods/static_softmax.html#ivy.container.container_methods.static_softmax">[docs]</a><span class="k">def</span> <span class="nf">static_softmax</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.softmax.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softmax also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the softmax should be computed</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softmax unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 0, 1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_softmax(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.422, 0.155, 0.422])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="softmax"><a class="viewcode-back" href="../../../container/container_methods/softmax.html#ivy.container.container_methods.softmax">[docs]</a><span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.softmax.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softmax also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis or axes along which the softmax should be computed</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softmax unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.0, 0, 1.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.softmax()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.422, 0.155, 0.422])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_softplus"><a class="viewcode-back" href="../../../container/container_methods/static_softplus.html#ivy.container.container_methods.static_softplus">[docs]</a><span class="k">def</span> <span class="nf">static_softplus</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.softplus.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softplus also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softplus unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-0.3461, -0.6491]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_softplus(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.535, 0.42])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="softplus"><a class="viewcode-back" href="../../../container/container_methods/softplus.html#ivy.container.container_methods.softplus">[docs]</a><span class="k">def</span> <span class="nf">softplus</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.softplus.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.softplus also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container with the softplus unit function applied element-wise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-0.3461, -0.6491]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.softplus()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.535, 0.42])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.base</span>
<span class="sd">&quot;&quot;&quot;Base Container Object.&quot;&quot;&quot;</span>

<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">termcolor</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">json</span>


<span class="k">try</span><span class="p">:</span>
    <span class="c1"># noinspection PyPackageRequirements</span>
    <span class="kn">import</span> <span class="nn">h5py</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="n">h5py</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">set</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<span class="n">ansi_escape</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\x1B(?:[@-Z</span><span class="se">\\</span><span class="s2">-_]|\[[0-?]*[ -/]*[@-~])&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_jsonable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<span class="c1">#ivy.container.container</span>
<span class="c1"># global</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">.activations</span> <span class="kn">import</span> <span class="n">ContainerWithActivations</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">from</span> <span class="nn">.conversions</span> <span class="kn">import</span> <span class="n">ContainerWithConversions</span>
<span class="kn">from</span> <span class="nn">.creation</span> <span class="kn">import</span> <span class="n">ContainerWithCreation</span>
<span class="kn">from</span> <span class="nn">.data_type</span> <span class="kn">import</span> <span class="n">ContainerWithDataTypes</span>
<span class="kn">from</span> <span class="nn">.device</span> <span class="kn">import</span> <span class="n">ContainerWithDevice</span>
<span class="kn">from</span> <span class="nn">.elementwise</span> <span class="kn">import</span> <span class="n">ContainerWithElementwise</span>
<span class="kn">from</span> <span class="nn">.general</span> <span class="kn">import</span> <span class="n">ContainerWithGeneral</span>
<span class="kn">from</span> <span class="nn">.gradients</span> <span class="kn">import</span> <span class="n">ContainerWithGradients</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">ContainerWithImage</span>
<span class="kn">from</span> <span class="nn">.layers</span> <span class="kn">import</span> <span class="n">ContainerWithLayers</span>
<span class="kn">from</span> <span class="nn">.linear_algebra</span> <span class="kn">import</span> <span class="n">ContainerWithLinearAlgebra</span>
<span class="kn">from</span> <span class="nn">.losses</span> <span class="kn">import</span> <span class="n">ContainerWithLosses</span>
<span class="kn">from</span> <span class="nn">.manipulation</span> <span class="kn">import</span> <span class="n">ContainerWithManipulation</span>
<span class="kn">from</span> <span class="nn">.norms</span> <span class="kn">import</span> <span class="n">ContainerWithNorms</span>
<span class="kn">from</span> <span class="nn">.random</span> <span class="kn">import</span> <span class="n">ContainerWithRandom</span>
<span class="kn">from</span> <span class="nn">.searching</span> <span class="kn">import</span> <span class="n">ContainerWithSearching</span>
<span class="kn">from</span> <span class="nn">.set</span> <span class="kn">import</span> <span class="n">ContainerWithSet</span>
<span class="kn">from</span> <span class="nn">.sorting</span> <span class="kn">import</span> <span class="n">ContainerWithSorting</span>
<span class="kn">from</span> <span class="nn">.statistical</span> <span class="kn">import</span> <span class="n">ContainerWithStatistical</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="kn">import</span> <span class="n">ContainerWithUtility</span>


<div class="viewcode-block" id="__init__"><a class="viewcode-back" href="../../../container/container_methods.html#ivy.container.container_methods.__init__">[docs]</a><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dict_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">queues</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">queue_load_sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">container_combine_method</span><span class="o">=</span><span class="s2">&quot;list_join&quot;</span><span class="p">,</span>
    <span class="n">queue_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_limit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">key_length_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_indent</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">print_line_spacing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">ivyh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_key_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
    <span class="n">keyword_color_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rebuild_child_containers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">types_to_iteratively_nest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alphabetical_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="k">pass</span></div>


<span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="__add__"><a class="viewcode-back" href="../../../container/container_methods.html#ivy.container.container_methods.__add__">[docs]</a><span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container special method for the add operator, calling :code:`operator.add`</span>
<span class="sd">    for each of the corresponding leaves of the two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`Number` instances at the leaves:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=1, b=2)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=3, b=4)</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: 4,</span>
<span class="sd">        b: 6</span>
<span class="sd">    }</span>

<span class="sd">    With :code:`ivy.Array` instances at the leaves:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                          b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]), \</span>
<span class="sd">                          b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 9]),</span>
<span class="sd">        b: ivy.array([7, 9, 11])</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Container` and :code:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[4.], [5.], [6.]]),\</span>
<span class="sd">                          b=ivy.array([[5.], [6.], [7.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([[1.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[5.1, 6.3, 0.4],</span>
<span class="sd">                      [6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4]]),</span>
<span class="sd">        b: ivy.array([[6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4],</span>
<span class="sd">                      [8.1, 9.3, 3.4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="__radd__"><a class="viewcode-back" href="../../../container/container_methods.html#ivy.container.container_methods.__radd__">[docs]</a><span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container reverse special method for the add operator, calling</span>
<span class="sd">    :code:`operator.add` for each of the corresponding leaves of the two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = 1</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=3, b=4)</span>
<span class="sd">    &gt;&gt;&gt; z = x + y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: 4,</span>
<span class="sd">        b: 5</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="__rshift__"><a class="viewcode-back" href="../../../container/container_methods.html#ivy.container.container_methods.__rshift__">[docs]</a><span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container special method for the right shift operator, calling </span>
<span class="sd">    :code:`operator.rshift` for each of the corresponding leaves of the</span>
<span class="sd">    two containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self`` </span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer data type. </span>
<span class="sd">        Each element must be greater than or equal to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array </span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`Number` instances at the leaves:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=128, b=43)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=5, b=3)</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;&gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: 4,</span>
<span class="sd">        b: 5</span>
<span class="sd">    }</span>

<span class="sd">    With :code:`ivy.Array` instances at the leaves:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([16, 40, 120]),\</span>
<span class="sd">                          b=ivy.array([15, 45, 143]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]), \</span>
<span class="sd">                          b=ivy.array([0, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;&gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8, 10, 15]),</span>
<span class="sd">        b: ivy.array([15, 5, 8])</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Container` and :code:`ivy.Array` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([16, 40, 120]),\</span>
<span class="sd">                          b=ivy.array([15, 45, 143]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; z = x &gt;&gt; y</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8, 10, 15]),</span>
<span class="sd">        b: ivy.array([7, 11, 17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="__rrshift__"><a class="viewcode-back" href="../../../container/container_methods.html#ivy.container.container_methods.__rrshift__">[docs]</a><span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container reverse special method for the right shift operator, calling</span>
<span class="sd">    :code:`operator.rshift` for each of the corresponding leaves of the two</span>
<span class="sd">    containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have an integer data type.</span>
<span class="sd">    other</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have an integer data type. Each element</span>
<span class="sd">        must be greater than or equal to ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = 64</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(a = ivy.array([0, 1, 2]), \</span>
<span class="sd">                          b = ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = a &gt;&gt; b</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([64, 32, 16]),</span>
<span class="sd">        b: ivy.array([8, 4, 2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1">#ivy.container.conversions</span>
<span class="sd">&quot;&quot;&quot;Collection of Ivy functions for wrapping functions to accept and return</span>
<span class="sd">ivy.Container instances.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<div class="viewcode-block" id="static_to_native"><a class="viewcode-back" href="../../../container/container_methods/static_to_native.html#ivy.container.container_methods.static_to_native">[docs]</a><span class="k">def</span> <span class="nf">static_to_native</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_native. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_native also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so, all</span>
<span class="sd">        dicts, lists and tuples will be traversed to their lowest leaves in search</span>
<span class="sd">        of ivy.Array and ivy.Variable instances. Default is False.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all sub-arrays converted to their native format.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="to_native"><a class="viewcode-back" href="../../../container/container_methods/to_native.html#ivy.container.container_methods.to_native">[docs]</a><span class="k">def</span> <span class="nf">to_native</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_native. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_native also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so, all</span>
<span class="sd">        dicts, lists and tuples will be traversed to their lowest leaves in search</span>
<span class="sd">        of ivy.Array and ivy.Variable instances. Default is False.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all sub-arrays converted to their native format.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_to_ivy"><a class="viewcode-back" href="../../../container/container_methods/static_to_ivy.html#ivy.container.container_methods.static_to_ivy">[docs]</a><span class="k">def</span> <span class="nf">static_to_ivy</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_ivy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_ivy also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so, all</span>
<span class="sd">        dicts, lists and tuples will be traversed to their lowest leaves in search</span>
<span class="sd">        of ivy.Array and ivy.Variable instances. Default is False.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all native sub-arrays converted to their ivy.Array</span>
<span class="sd">        instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="to_ivy"><a class="viewcode-back" href="../../../container/container_methods/to_ivy.html#ivy.container.container_methods.to_ivy">[docs]</a><span class="k">def</span> <span class="nf">to_ivy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_derived</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_ivy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.to_ivy also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to be converted.</span>
<span class="sd">    nested</span>
<span class="sd">        Whether to apply the conversion on arguments in a nested manner. If so,</span>
<span class="sd">        all dicts, lists and tuples will be traversed to their lowest leaves in</span>
<span class="sd">        search of ivy.Array and ivy.Variable instances. Default is False.</span>
<span class="sd">    include_derived</span>
<span class="sd">        Whether to also recursive for classes derived from tuple, list and dict.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container object with all native sub-arrays converted to their ivy.Array</span>
<span class="sd">        instances.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.creation</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_arange"><a class="viewcode-back" href="../../../container/container_methods/static_arange.html#ivy.container.container_methods.static_arange">[docs]</a><span class="k">def</span> <span class="nf">static_arange</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Number</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">step</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_asarray"><a class="viewcode-back" href="../../../container/container_methods/static_asarray.html#ivy.container.container_methods.static_asarray">[docs]</a><span class="k">def</span> <span class="nf">static_asarray</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_zeros"><a class="viewcode-back" href="../../../container/container_methods/static_zeros.html#ivy.container.container_methods.static_zeros">[docs]</a><span class="k">def</span> <span class="nf">static_zeros</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_ones"><a class="viewcode-back" href="../../../container/container_methods/static_ones.html#ivy.container.container_methods.static_ones">[docs]</a><span class="k">def</span> <span class="nf">static_ones</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_full_like"><a class="viewcode-back" href="../../../container/container_methods/static_full_like.html#ivy.container.container_methods.static_full_like">[docs]</a><span class="k">def</span> <span class="nf">static_full_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.full_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.full_like also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    fill_value</span>
<span class="sd">        Scalar fill value</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is `None`, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``x`` and whose elements,</span>
<span class="sd">        relative to ``x``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With ivy.Container input</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([1,2,3]) ,b = ivy.array([4,5,6]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 10</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.full_like(fill_value)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10, 10, 10]),</span>
<span class="sd">        b: ivy.array([10, 10, 10])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.2,2.2324,3.234]), \</span>
<span class="sd">                           b=ivy.array([4.123,5.23,6.23]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 15.0</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([15., 15., 15.]),</span>
<span class="sd">        b: ivy.array([15., 15., 15.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="full_like"><a class="viewcode-back" href="../../../container/container_methods/full_like.html#ivy.container.container_methods.full_like">[docs]</a><span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.full_like. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.full_like also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    fill_value</span>
<span class="sd">        Scalar fill value</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is `None`, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If ``device`` is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``x`` and whose elements,</span>
<span class="sd">        relative to ``x``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With ivy.Container input</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([1,2,3]) ,b = ivy.array([4,5,6]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 10</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10, 10, 10]),</span>
<span class="sd">        b: ivy.array([10, 10, 10])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.2,2.2324,3.234]), \</span>
<span class="sd">                           b=ivy.array([4.123,5.23,6.23]))</span>
<span class="sd">    &gt;&gt;&gt; fill_value = 15.0</span>
<span class="sd">    &gt;&gt;&gt; y = x.full_like(fill_value)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([15., 15., 15.]),</span>
<span class="sd">        b: ivy.array([15., 15., 15.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_ones_like"><a class="viewcode-back" href="../../../container/container_methods/static_ones_like.html#ivy.container.container_methods.static_ones_like">[docs]</a><span class="k">def</span> <span class="nf">static_ones_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.ones_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.ones_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container having the same shape as ``self`` and filled with ones.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ones_like"><a class="viewcode-back" href="../../../container/container_methods/ones_like.html#ivy.container.container_methods.ones_like">[docs]</a><span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.ones_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.ones_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array from which to derive the output array shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output array data type</span>
<span class="sd">        must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output array device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container having the same shape as ``self`` and filled with ones.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_zeros_like"><a class="viewcode-back" href="../../../container/container_methods/static_zeros_like.html#ivy.container.container_methods.static_zeros_like">[docs]</a><span class="k">def</span> <span class="nf">static_zeros_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.zeros_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zeros_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container from which to derive the output container shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output container</span>
<span class="sd">        data type must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output container device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container having the same shape as ``x`` and filled with ``zeros``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="zeros_like"><a class="viewcode-back" href="../../../container/container_methods/zeros_like.html#ivy.container.container_methods.zeros_like">[docs]</a><span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.zeros_like. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zeros_like also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container from which to derive the output container shape.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        output array data type. If ``dtype`` is ``None``, the output container</span>
<span class="sd">        data type must be inferred from ``self``. Default  ``None``.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to place the created array. If device is ``None``, the</span>
<span class="sd">        output container device must be inferred from ``self``. Default: ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container having the same shape as ``x`` and filled with ``zeros``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_tril"><a class="viewcode-back" href="../../../container/container_methods/static_tril.html#ivy.container.container_methods.static_tril">[docs]</a><span class="k">def</span> <span class="nf">static_tril</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tril"><a class="viewcode-back" href="../../../container/container_methods/tril.html#ivy.container.container_methods.tril">[docs]</a><span class="k">def</span> <span class="nf">tril</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_triu"><a class="viewcode-back" href="../../../container/container_methods/static_triu.html#ivy.container.container_methods.static_triu">[docs]</a><span class="k">def</span> <span class="nf">static_triu</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="triu"><a class="viewcode-back" href="../../../container/container_methods/triu.html#ivy.container.container_methods.triu">[docs]</a><span class="k">def</span> <span class="nf">triu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_empty_like"><a class="viewcode-back" href="../../../container/container_methods/static_empty_like.html#ivy.container.container_methods.static_empty_like">[docs]</a><span class="k">def</span> <span class="nf">static_empty_like</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="empty_like"><a class="viewcode-back" href="../../../container/container_methods/empty_like.html#ivy.container.container_methods.empty_like">[docs]</a><span class="k">def</span> <span class="nf">empty_like</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_eye"><a class="viewcode-back" href="../../../container/container_methods/static_eye.html#ivy.container.container_methods.static_eye">[docs]</a><span class="k">def</span> <span class="nf">static_eye</span><span class="p">(</span>
    <span class="n">n_rows</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_linspace"><a class="viewcode-back" href="../../../container/container_methods/static_linspace.html#ivy.container.container_methods.static_linspace">[docs]</a><span class="k">def</span> <span class="nf">static_linspace</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_meshgrid"><a class="viewcode-back" href="../../../container/container_methods/static_meshgrid.html#ivy.container.container_methods.static_meshgrid">[docs]</a><span class="k">def</span> <span class="nf">static_meshgrid</span><span class="p">(</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span>
    <span class="n">indexing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="meshgrid"><a class="viewcode-back" href="../../../container/container_methods/meshgrid.html#ivy.container.container_methods.meshgrid">[docs]</a><span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">]],</span>
    <span class="n">indexing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_from_dlpack"><a class="viewcode-back" href="../../../container/container_methods/static_from_dlpack.html#ivy.container.container_methods.static_from_dlpack">[docs]</a><span class="k">def</span> <span class="nf">static_from_dlpack</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="from_dlpack"><a class="viewcode-back" href="../../../container/container_methods/from_dlpack.html#ivy.container.container_methods.from_dlpack">[docs]</a><span class="k">def</span> <span class="nf">from_dlpack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_native_array"><a class="viewcode-back" href="../../../container/container_methods/static_native_array.html#ivy.container.container_methods.static_native_array">[docs]</a><span class="k">def</span> <span class="nf">static_native_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="native_array"><a class="viewcode-back" href="../../../container/container_methods/native_array.html#ivy.container.container_methods.native_array">[docs]</a><span class="k">def</span> <span class="nf">native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_logspace"><a class="viewcode-back" href="../../../container/container_methods/static_logspace.html#ivy.container.container_methods.static_logspace">[docs]</a><span class="k">def</span> <span class="nf">static_logspace</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.data_type</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_astype"><a class="viewcode-back" href="../../../container/container_methods/static_astype.html#ivy.container.container_methods.static_astype">[docs]</a><span class="k">def</span> <span class="nf">static_astype</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Copies an array to a specified data type irrespective of </span>
<span class="sd">    :ref:`type-promotion` rules.</span>

<span class="sd">    .. note::</span>
<span class="sd">    Casting floating-point ``NaN`` and ``infinity`` values to integral data types </span>
<span class="sd">    is not specified and is implementation-dependent.</span>

<span class="sd">    .. note::</span>
<span class="sd">    When casting a boolean input array to a numeric data type, a value of ``True``</span>
<span class="sd">    must cast to a numeric value equal to ``1``, and a value of ``False`` must cast</span>
<span class="sd">    to a numeric value equal to ``0``.</span>

<span class="sd">    When casting a numeric input array to ``bool``, a value of ``0`` must cast to</span>
<span class="sd">    ``False``, and a non-zero value must cast to ``True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        array to cast.</span>
<span class="sd">    dtype</span>
<span class="sd">        desired data type.</span>
<span class="sd">    copy</span>
<span class="sd">        specifies whether to copy an array when the specified ``dtype`` matches </span>
<span class="sd">        the data type of the input array ``x``. If ``True``, a newly allocated </span>
<span class="sd">        array must always be returned. If ``False`` and the specified ``dtype``</span>
<span class="sd">        matches the data type of the input array, the input array must be returned;</span>
<span class="sd">        otherwise, a newly allocated must be returned. Default: ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape </span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the specified data type. The returned array must have </span>
<span class="sd">        the same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; c = ivy.Container(a=ivy.array([False,True,True]), \</span>
<span class="sd">                             b=ivy.array([3.14, 2.718, 1.618]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_astype(c, ivy.int32)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 1]),</span>
<span class="sd">        b: ivy.array([3, 2, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="astype"><a class="viewcode-back" href="../../../container/container_methods/astype.html#ivy.container.container_methods.astype">[docs]</a><span class="k">def</span> <span class="nf">astype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Copies an array to a specified data type irrespective of </span>
<span class="sd">    :ref:`type-promotion` rules.</span>

<span class="sd">    .. note::</span>
<span class="sd">    Casting floating-point ``NaN`` and ``infinity`` values to integral data types</span>
<span class="sd">    is not specified and is implementation-dependent.</span>

<span class="sd">    .. note::</span>
<span class="sd">    When casting a boolean input array to a numeric data type, a value of ``True``</span>
<span class="sd">    must cast to a numeric value equal to ``1``, and a value of ``False`` must cast</span>
<span class="sd">    to a numeric value equal to ``0``.</span>

<span class="sd">    When casting a numeric input array to ``bool``, a value of ``0`` must cast to</span>
<span class="sd">    ``False``, and a non-zero value must cast to ``True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        array to cast.</span>
<span class="sd">    dtype</span>
<span class="sd">        desired data type.</span>
<span class="sd">    copy</span>
<span class="sd">        specifies whether to copy an array when the specified ``dtype`` matches </span>
<span class="sd">        the data type of the input array ``x``. If ``True``, a newly allocated </span>
<span class="sd">        array must always be returned. If ``False`` and the specified ``dtype``</span>
<span class="sd">        matches the data type of the input array, the input array must be returned;</span>
<span class="sd">        otherwise, a newly allocated must be returned. Default: ``True``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">         that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array having the specified data type. The returned array must have </span>
<span class="sd">        the same shape as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` instance method:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([False,True,True]), \</span>
<span class="sd">                            b=ivy.array([3.14, 2.718, 1.618]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.astype(ivy.int32))</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 1]),</span>
<span class="sd">        b: ivy.array([3, 2, 1])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_broadcast_arrays"><a class="viewcode-back" href="../../../container/container_methods/static_broadcast_arrays.html#ivy.container.container_methods.static_broadcast_arrays">[docs]</a><span class="k">def</span> <span class="nf">static_broadcast_arrays</span><span class="p">(</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.broadcast_arrays`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.broadcast_arrays`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of arrays to-be broadcasted.</span>
<span class="sd">        Each array must have the same shape.</span>
<span class="sd">        And Each array must have the same dtype as its</span>
<span class="sd">        corresponding input array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list of containers containing broadcasted arrays</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2]), b=ivy.array([3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([-1.2, 0.4]), b=ivy.array([0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_broadcast_arrays(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([1, 2]),</span>
<span class="sd">        b: ivy.array([3, 4])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([-1.2, 0.4]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }]</span>

<span class="sd">    With mixed :code:`ivy.Container` and :code:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4, 5]), b=ivy.array([2, -1]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([0.2, 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_broadcast_arrays(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([4, 5]),</span>
<span class="sd">        b: ivy.array([2, -1])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0.2, 3.]),</span>
<span class="sd">        b: ivy.array([0.2, 3.])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="broadcast_arrays"><a class="viewcode-back" href="../../../container/container_methods/broadcast_arrays.html#ivy.container.container_methods.broadcast_arrays">[docs]</a><span class="k">def</span> <span class="nf">broadcast_arrays</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.broadcast_arrays`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.broadcast_arrays`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        A container to be broadcatsed against other input arrays.</span>
<span class="sd">    arrays</span>
<span class="sd">        an arbitrary number of containers having arrays to-be broadcasted.</span>
<span class="sd">        Each array must have the same shape.</span>
<span class="sd">        Each array must have the same dtype as its corresponding input array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 2]), b=ivy.array([3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([-1.2, 0.4]), b=ivy.array([0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([1, 2]),</span>
<span class="sd">        b: ivy.array([3, 4])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([-1.2, 0.4]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }]</span>

<span class="sd">    With mixed :code:`ivy.Container` and :code:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4, 5]), b=ivy.array([2, -1]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.zeros(2)</span>
<span class="sd">    &gt;&gt;&gt; y = x1.broadcast_arrays(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([4, 5]),</span>
<span class="sd">        b: ivy.array([2, -1])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.]),</span>
<span class="sd">        b: ivy.array([0., 0.])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_broadcast_to"><a class="viewcode-back" href="../../../container/container_methods/static_broadcast_to.html#ivy.container.container_methods.static_broadcast_to">[docs]</a><span class="k">def</span> <span class="nf">static_broadcast_to</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.broadcast_to`.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for `ivy.broadcast_to` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array to be broadcasted.</span>
<span class="sd">    shape</span>
<span class="sd">        desired shape to be broadcasted to.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array to store the broadcasted array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns the broadcasted array of shape &#39;shape&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` static method:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1]),\</span>
<span class="sd">        b=ivy.array([2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_broadcast_to(x,(3, 1))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1],</span>
<span class="sd">                     [1],</span>
<span class="sd">                     [1]),</span>
<span class="sd">        b: ivy.array([2],</span>
<span class="sd">                     [2],</span>
<span class="sd">                     [2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="broadcast_to"><a class="viewcode-back" href="../../../container/container_methods/broadcast_to.html#ivy.container.container_methods.broadcast_to">[docs]</a><span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.broadcast_to`.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for `ivy.broadcast_to` also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array to be broadcasted.</span>
<span class="sd">    shape</span>
<span class="sd">        desired shape to be broadcasted to.</span>
<span class="sd">    out</span>
<span class="sd">        Optional array to store the broadcasted array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns the broadcasted array of shape &#39;shape&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code: &#39;ivy.Container&#39; instance method:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0.5]),\</span>
<span class="sd">        b=ivy.array([4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.broadcast_to((3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 0.5],</span>
<span class="sd">                      [0., 0.5],</span>
<span class="sd">                      [0., 0.5]]),</span>
<span class="sd">        b: ivy.array([[4, 5],</span>
<span class="sd">                      [4, 5],</span>
<span class="sd">                      [4, 5]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_can_cast"><a class="viewcode-back" href="../../../container/container_methods/static_can_cast.html#ivy.container.container_methods.static_can_cast">[docs]</a><span class="k">def</span> <span class="nf">static_can_cast</span><span class="p">(</span>
    <span class="n">from_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">to</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.can_cast`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.can_cast` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    from_</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    to</span>
<span class="sd">        desired data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        ``True`` if the cast can occur according to :ref:`type-promotion` rules;</span>
<span class="sd">        otherwise, ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">        b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>

<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_can_cast(x, &#39;int64&#39;))</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="can_cast"><a class="viewcode-back" href="../../../container/container_methods/can_cast.html#ivy.container.container_methods.can_cast">[docs]</a><span class="k">def</span> <span class="nf">can_cast</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">to</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.can_cast`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.can_cast` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    to</span>
<span class="sd">        desired data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        ``True`` if the cast can occur according to :ref:`type-promotion` rules;</span>
<span class="sd">        otherwise, ``False``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">        b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>

<span class="sd">    &gt;&gt;&gt; print(x.can_cast(&#39;int64&#39;))</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_dtype"><a class="viewcode-back" href="../../../container/container_methods/static_dtype.html#ivy.container.container_methods.static_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_dtype</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">as_native</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="dtype"><a class="viewcode-back" href="../../../container/container_methods/dtype.html#ivy.container.container_methods.dtype">[docs]</a><span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">as_native</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_default_float_dtype"><a class="viewcode-back" href="../../../container/container_methods/static_default_float_dtype.html#ivy.container.container_methods.static_default_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_default_float_dtype</span><span class="p">(</span>
    <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">float_dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">FloatDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">as_native</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_function_supported_dtypes"><a class="viewcode-back" href="../../../container/container_methods/static_function_supported_dtypes.html#ivy.container.container_methods.static_function_supported_dtypes">[docs]</a><span class="k">def</span> <span class="nf">static_function_supported_dtypes</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_function_unsupported_dtypes"><a class="viewcode-back" href="../../../container/container_methods/static_function_unsupported_dtypes.html#ivy.container.container_methods.static_function_unsupported_dtypes">[docs]</a><span class="k">def</span> <span class="nf">static_function_unsupported_dtypes</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_finfo"><a class="viewcode-back" href="../../../container/container_methods/static_finfo.html#ivy.container.container_methods.static_finfo">[docs]</a><span class="k">def</span> <span class="nf">static_finfo</span><span class="p">(</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="finfo"><a class="viewcode-back" href="../../../container/container_methods/finfo.html#ivy.container.container_methods.finfo">[docs]</a><span class="k">def</span> <span class="nf">finfo</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_iinfo"><a class="viewcode-back" href="../../../container/container_methods/static_iinfo.html#ivy.container.container_methods.static_iinfo">[docs]</a><span class="k">def</span> <span class="nf">static_iinfo</span><span class="p">(</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="iinfo"><a class="viewcode-back" href="../../../container/container_methods/iinfo.html#ivy.container.container_methods.iinfo">[docs]</a><span class="k">def</span> <span class="nf">iinfo</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_bool_dtype"><a class="viewcode-back" href="../../../container/container_methods/static_is_bool_dtype.html#ivy.container.container_methods.static_is_bool_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_bool_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_bool_dtype"><a class="viewcode-back" href="../../../container/container_methods/is_bool_dtype.html#ivy.container.container_methods.is_bool_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_bool_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_float_dtype"><a class="viewcode-back" href="../../../container/container_methods/static_is_float_dtype.html#ivy.container.container_methods.static_is_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_float_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `is_float_dtype`. This method</span>
<span class="sd">    simply wraps this function, so the docstring of `is_float_dtype`</span>
<span class="sd">    roughly applies to this method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype_in : ivy.Container</span>
<span class="sd">        The input to check for float dtype.</span>

<span class="sd">    key_chains : Optional[Union[List[str], Dict[str, str]]]</span>
<span class="sd">        The key chains to use when mapping over the input.</span>

<span class="sd">    to_apply : bool</span>
<span class="sd">        Whether to apply the mapping over the input.</span>

<span class="sd">    prune_unapplied : bool</span>
<span class="sd">        Whether to prune the keys that were not applied.</span>

<span class="sd">    map_sequences : bool</span>
<span class="sd">        Boolean indicating whether to map method</span>
<span class="sd">        to sequences (list, tuple). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : bool</span>
<span class="sd">        Boolean indicating whether the input has float dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.int64)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.int32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.static_is_float_dtype(ivy.bool)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; arr = ivy.array([1.2, 3.2, 4.3], dtype=ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(arr.is_float_dtype())</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_float_dtype"><a class="viewcode-back" href="../../../container/container_methods/is_float_dtype.html#ivy.container.container_methods.is_float_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_float_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.is_float_dtype`.</span>
<span class="sd">    This method simply wraps the function,</span>
<span class="sd">    and so the docstring for `ivy.is_float_dtype`</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : ivy.Container</span>
<span class="sd">        The `ivy.Container` instance to call `ivy.is_float_dtype` on.</span>

<span class="sd">    key_chains : Union[List[str], Dict[str, str]]</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is None.</span>

<span class="sd">    to_apply : bool</span>
<span class="sd">        Boolean indicating whether to apply the</span>
<span class="sd">        method to the key-chains. Default is False.</span>

<span class="sd">    prune_unapplied : bool</span>
<span class="sd">        Boolean indicating whether to prune the</span>
<span class="sd">        key-chains that were not applied. Default is False.</span>

<span class="sd">    map_sequences : bool</span>
<span class="sd">        Boolean indicating whether to map method</span>
<span class="sd">        to sequences (list, tuple). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : bool</span>
<span class="sd">        Boolean of whether the input is of a float dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.int64)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.int32)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.is_float_dtype(ivy.bool)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; arr = ivy.array([1.2, 3.2, 4.3], dtype=ivy.float32)</span>
<span class="sd">    &gt;&gt;&gt; print(arr.is_float_dtype())</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    float32 int32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_int_dtype"><a class="viewcode-back" href="../../../container/container_methods/static_is_int_dtype.html#ivy.container.container_methods.static_is_int_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_int_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_int_dtype"><a class="viewcode-back" href="../../../container/container_methods/is_int_dtype.html#ivy.container.container_methods.is_int_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_int_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_uint_dtype"><a class="viewcode-back" href="../../../container/container_methods/static_is_uint_dtype.html#ivy.container.container_methods.static_is_uint_dtype">[docs]</a><span class="k">def</span> <span class="nf">static_is_uint_dtype</span><span class="p">(</span>
    <span class="n">dtype_in</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_uint_dtype"><a class="viewcode-back" href="../../../container/container_methods/is_uint_dtype.html#ivy.container.container_methods.is_uint_dtype">[docs]</a><span class="k">def</span> <span class="nf">is_uint_dtype</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_result_type"><a class="viewcode-back" href="../../../container/container_methods/static_result_type.html#ivy.container.container_methods.static_result_type">[docs]</a><span class="k">def</span> <span class="nf">static_result_type</span><span class="p">(</span>
    <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` static method variant of `ivy.result_type`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.result_type` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    arrays_and_dtypes</span>
<span class="sd">        an arbitrary number of input arrays and/or dtypes.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the dtype resulting from an operation involving the input arrays and dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([0, 1, 2]), \</span>
<span class="sd">                          b = ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype, x.b.dtype)</span>
<span class="sd">    int32 float32</span>

<span class="sd">    &gt;&gt;&gt; print(ivy.Container.static_result_type(x, ivy.float64))</span>
<span class="sd">    {</span>
<span class="sd">        a: float64,</span>
<span class="sd">        b: float32</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="result_type"><a class="viewcode-back" href="../../../container/container_methods/result_type.html#ivy.container.container_methods.result_type">[docs]</a><span class="k">def</span> <span class="nf">result_type</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `ivy.Container` instance method variant of `ivy.result_type`. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for `ivy.result_type` also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container from which to cast.</span>
<span class="sd">    arrays_and_dtypes</span>
<span class="sd">        an arbitrary number of input arrays and/or dtypes.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        the dtype resulting from an operation involving the input arrays and dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array([3, 3, 3]))</span>
<span class="sd">    &gt;&gt;&gt; print(x.a.dtype)</span>
<span class="sd">    int32</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(b = ivy.float64)</span>
<span class="sd">    &gt;&gt;&gt; print(x.result_type(y))</span>
<span class="sd">    {</span>
<span class="sd">        a: {</span>
<span class="sd">            b: float64</span>
<span class="sd">        }</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.device</span>
<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># ToDo: implement all methods here as public instance methods</span>

<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_dev"><a class="viewcode-back" href="../../../container/container_methods/static_dev.html#ivy.container.container_methods.static_dev">[docs]</a><span class="k">def</span> <span class="nf">static_dev</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.dev. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dev also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="dev"><a class="viewcode-back" href="../../../container/container_methods/dev.html#ivy.container.container_methods.dev">[docs]</a><span class="k">def</span> <span class="nf">dev</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">as_native</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.dev. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.dev also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_to_device"><a class="viewcode-back" href="../../../container/container_methods/static_to_device.html#ivy.container.container_methods.static_to_device">[docs]</a><span class="k">def</span> <span class="nf">static_to_device</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_device. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.to_device also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">       input array to be moved to the desired device</span>
<span class="sd">    device</span>
<span class="sd">        device to move the input array `x` to</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    stream</span>
<span class="sd">        stream object to use during copy. In addition to the types supported</span>
<span class="sd">        in array.__dlpack__(), implementations may choose to support any</span>
<span class="sd">        library-specific stream object with the caveat that any code using</span>
<span class="sd">        such an object would not be portable.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        input array x placed on the desired device</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="to_device"><a class="viewcode-back" href="../../../functional/ivy/device/to_device/to_device_container.html#ivy.container.container_methods.to_device">[docs]</a><span class="k">def</span> <span class="nf">to_device</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_device. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.to_device also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">       input array to be moved to the desired device</span>
<span class="sd">    device</span>
<span class="sd">        device to move the input array `x` to</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    stream</span>
<span class="sd">        stream object to use during copy. In addition to the types supported</span>
<span class="sd">        in array.__dlpack__(), implementations may choose to support any</span>
<span class="sd">        library-specific stream object with the caveat that any code using</span>
<span class="sd">        such an object would not be portable.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        input array x placed on the desired device</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.elementwise</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_abs"><a class="viewcode-back" href="../../../container/container_methods/static_abs.html#ivy.container.container_methods.static_abs">[docs]</a><span class="k">def</span> <span class="nf">static_abs</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.abs. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.abs also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the absolute value of each element in ``x``. The</span>
<span class="sd">        returned container must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),\</span>
<span class="sd">                        b=ivy.array([4.5, -5.3, -0, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_abs(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 2.6, 3.5]),</span>
<span class="sd">        b: ivy.array([4.5, 5.3, 0, 2.3])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../container/container_methods/abs.html#ivy.container.container_methods.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.abs. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.abs also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the absolute value of each element in ``self``. The</span>
<span class="sd">        returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1.6, 2.6, -3.5]),\</span>
<span class="sd">                        b=ivy.array([4.5, -5.3, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.abs()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.6, 2.6, 3.5]),</span>
<span class="sd">        b: ivy.array([4.5, 5.3, 2.3])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_acosh"><a class="viewcode-back" href="../../../container/container_methods/static_acosh.html#ivy.container.container_methods.static_acosh">[docs]</a><span class="k">def</span> <span class="nf">static_acosh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic cosine of each element</span>
<span class="sd">        in ``x``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 2., 3, 4]),\</span>
<span class="sd">                          b=ivy.array([1., 3., 10.0, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_acosh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.32, 1.76, 2.06]),</span>
<span class="sd">        b: ivy.array([0., 1.76, 2.99, 2.48])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="acosh"><a class="viewcode-back" href="../../../container/container_methods/acosh.html#ivy.container.container_methods.acosh">[docs]</a><span class="k">def</span> <span class="nf">acosh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.acosh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.acosh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic cosine of each element in</span>
<span class="sd">        ``self``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 2., 3, 4]),\</span>
<span class="sd">                          b=ivy.array([1., 3., 10.0, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.acosh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.32, 1.76, 2.06]),</span>
<span class="sd">        b: ivy.array([0., 1.76, 2.99, 2.48])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_acos"><a class="viewcode-back" href="../../../container/container_methods/static_acos.html#ivy.container.container_methods.static_acos">[docs]</a><span class="k">def</span> <span class="nf">static_acos</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.acos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.acos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse cosine of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_acos(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.57, 3.14, 0.]),</span>
<span class="sd">        b: ivy.array([0., 1.57, 3.14])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_add"><a class="viewcode-back" href="../../../container/container_methods/static_add.html#ivy.container.container_methods.static_add">[docs]</a><span class="k">def</span> <span class="nf">static_add</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.add.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.add also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([[1.1, 2.3, -3.6]])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[4.], [5.], [6.]]),\</span>
<span class="sd">                        b=ivy.array([[5.], [6.], [7.]]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_add(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[5.1, 6.3, 0.4],</span>
<span class="sd">                      [6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4]]),</span>
<span class="sd">        b: ivy.array([[6.1, 7.3, 1.4],</span>
<span class="sd">                      [7.1, 8.3, 2.4],</span>
<span class="sd">                      [8.1, 9.3, 3.4]])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), \</span>
<span class="sd">                        b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                        b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_add(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 9]),</span>
<span class="sd">        b: ivy.array([7, 9, 11])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="acos"><a class="viewcode-back" href="../../../container/container_methods/acos.html#ivy.container.container_methods.acos">[docs]</a><span class="k">def</span> <span class="nf">acos</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.acos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.acos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse cosine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.acos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.57, 3.14, 0.]),</span>
<span class="sd">        b: ivy.array([0., 1.57, 3.14])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../container/container_methods/add.html#ivy.container.container_methods.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.add.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.add also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                         b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                         b=ivy.array([5, 6, 7]))</span>

<span class="sd">    &gt;&gt;&gt; z = x.add(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 9]),</span>
<span class="sd">        b: ivy.array([7, 9, 11])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_asin"><a class="viewcode-back" href="../../../container/container_methods/static_asin.html#ivy.container.container_methods.static_asin">[docs]</a><span class="k">def</span> <span class="nf">static_asin</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.asin.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.asin also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse sine of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -0.5, -1.]),\</span>
<span class="sd">                          b=ivy.array([0.1, 0.8, 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_asin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -0.524, -1.57]),</span>
<span class="sd">        b: ivy.array([0.1, 0.927, nan])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.4, 0.9, -0.9]),\</span>
<span class="sd">                          b=ivy.array([[4, -3, -0.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(3), b=ivy.zeros(3))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_asin(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.412, 1.12, -1.12]),</span>
<span class="sd">        b: ivy.array([nan, nan, -0.201])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="asin"><a class="viewcode-back" href="../../../container/container_methods/asin.html#ivy.container.container_methods.asin">[docs]</a><span class="k">def</span> <span class="nf">asin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.asin.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.asin also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse sine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 0.5, 1.]),\</span>
<span class="sd">                          b=ivy.array([-4., 0.8, 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.asin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.524, 1.57]),</span>
<span class="sd">        b: ivy.array([nan, 0.927, nan])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([12., 1.5, 0.]),\</span>
<span class="sd">                          b=ivy.array([-0.85, 0.6, 0.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(3), b=ivy.zeros(3))</span>
<span class="sd">    &gt;&gt;&gt; x.asin(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([nan, nan, 0.]),</span>
<span class="sd">        b: ivy.array([-1.02, 0.644, 0.305])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_asinh"><a class="viewcode-back" href="../../../container/container_methods/static_asinh.html#ivy.container.container_methods.static_asinh">[docs]</a><span class="k">def</span> <span class="nf">static_asinh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.asinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.asinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic sine of each element</span>
<span class="sd">        in ``x``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.5, 0., -3.5]),\</span>
<span class="sd">                        b=ivy.array([3.4, -5.3, -0, -2.8]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_asinh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.19, 0., -1.97]),</span>
<span class="sd">        b: ivy.array([1.94, -2.37, 0., -1.75])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="asinh"><a class="viewcode-back" href="../../../container/container_methods/asinh.html#ivy.container.container_methods.asinh">[docs]</a><span class="k">def</span> <span class="nf">asinh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.asinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.asinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic sine of each element in</span>
<span class="sd">        ``self``. The returned container must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 3.7, -5.1]),\</span>
<span class="sd">                        b=ivy.array([4.5, -2.4, -1.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.asinh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0.881, 2.02, -2.33]),</span>
<span class="sd">        b: ivy.array([2.21, -1.61, -1.19])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_atan"><a class="viewcode-back" href="../../../container/container_methods/static_atan.html#ivy.container.container_methods.static_atan">[docs]</a><span class="k">def</span> <span class="nf">static_atan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.atan. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.atan also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_atan(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -0.785, 0.785]),</span>
<span class="sd">        b: ivy.array([0.785, 0., -1.41])</span>
<span class="sd">    }</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="atan"><a class="viewcode-back" href="../../../container/container_methods/atan.html#ivy.container.container_methods.atan">[docs]</a><span class="k">def</span> <span class="nf">atan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.atan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.atan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -0.785, 0.785]),</span>
<span class="sd">        b: ivy.array([0.785, 0., -1.41])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_atan2"><a class="viewcode-back" href="../../../container/container_methods/static_atan2.html#ivy.container.container_methods.static_atan2">[docs]</a><span class="k">def</span> <span class="nf">static_atan2</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.atan2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atan2 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container corresponding to the y-coordinates.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container corresponding to the x-coordinates.</span>
<span class="sd">        Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a real-valued</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of the quotient ``x1/x2``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),\</span>
<span class="sd">                        b=ivy.array([4.5, -5.3, -0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3.0, 2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_atan2(x, y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.915, -1.29]),</span>
<span class="sd">        b: ivy.array([0.983, -1.21, 0.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),\</span>
<span class="sd">                          b=ivy.array([4.5, -5.3, -0, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([-2.5, 1.75, 3.5]),\</span>
<span class="sd">                          b=ivy.array([2.45, 6.35, 0, 1.5]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_atan2(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3.14, 0.978, -0.785]),</span>
<span class="sd">        b: ivy.array([1.07, -0.696, 0., -0.993])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="atan2"><a class="viewcode-back" href="../../../container/container_methods/atan2.html#ivy.container.container_methods.atan2">[docs]</a><span class="k">def</span> <span class="nf">atan2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.atan2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.atan2</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container corresponding to the y-coordinates.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container corresponding to the x-coordinates.</span>
<span class="sd">        Must be compatible with ``self`` (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse tangent of the quotient ``self/x2``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),\</span>
<span class="sd">                        b=ivy.array([4.5, -5.3, -0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.array([3.0, 2.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; x.atan2(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.915, -1.29]),</span>
<span class="sd">        b: ivy.array([0.983, -1.21, 0.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.6, -3.5]),\</span>
<span class="sd">                          b=ivy.array([4.5, -5.3, -0, -2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([-2.5, 1.75, 3.5]),\</span>
<span class="sd">                          b=ivy.array([2.45, 6.35, 0, 1.5]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.atan2(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3.14, 0.978, -0.785]),</span>
<span class="sd">        b: ivy.array([1.07, -0.696, 0., -0.993])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_atanh"><a class="viewcode-back" href="../../../container/container_methods/static_atanh.html#ivy.container.container_methods.static_atanh">[docs]</a><span class="k">def</span> <span class="nf">static_atanh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.atanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent the area of a hyperbolic</span>
<span class="sd">        sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic tangent of each</span>
<span class="sd">        element in ``x``. The returned container must have a floating-point data</span>
<span class="sd">        type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0.5, -0.5]), b=ivy.array([0., 0.2, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_atanh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.549, -0.549]),</span>
<span class="sd">        b: ivy.array([0., 0.203, 1.47])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="atanh"><a class="viewcode-back" href="../../../container/container_methods/atanh.html#ivy.container.container_methods.atanh">[docs]</a><span class="k">def</span> <span class="nf">atanh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.atanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.atanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent the area of a</span>
<span class="sd">        hyperbolic sector. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the inverse hyperbolic tangent of each element</span>
<span class="sd">        in ``self``. The returned container must have a floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0.5, -0.5]), b=ivy.array([0., 0.2, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.atanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.549, -0.549]),</span>
<span class="sd">        b: ivy.array([0., 0.203, 1.47])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_bitwise_and"><a class="viewcode-back" href="../../../container/container_methods/static_bitwise_and.html#ivy.container.container_methods.static_bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_and</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_and"><a class="viewcode-back" href="../../../container/container_methods/bitwise_and.html#ivy.container.container_methods.bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">bitwise_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_bitwise_left_shift"><a class="viewcode-back" href="../../../container/container_methods/static_bitwise_left_shift.html#ivy.container.container_methods.static_bitwise_left_shift">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_left_shift</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_left_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_left_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_left_shift"><a class="viewcode-back" href="../../../container/container_methods/bitwise_left_shift.html#ivy.container.container_methods.bitwise_left_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_left_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_left_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_left_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_bitwise_invert"><a class="viewcode-back" href="../../../container/container_methods/static_bitwise_invert.html#ivy.container.container_methods.static_bitwise_invert">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_invert</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_invert.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_invert also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_invert"><a class="viewcode-back" href="../../../container/container_methods/bitwise_invert.html#ivy.container.container_methods.bitwise_invert">[docs]</a><span class="k">def</span> <span class="nf">bitwise_invert</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_invert.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_invert also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_cos"><a class="viewcode-back" href="../../../container/container_methods/static_cos.html#ivy.container.container_methods.static_cos">[docs]</a><span class="k">def</span> <span class="nf">static_cos</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.cos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the cosine of each element in ``x``. The returned</span>
<span class="sd">        container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cos(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 0.54, 0.54]),</span>
<span class="sd">        b: ivy.array([0.54, 1., 0.96])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cos"><a class="viewcode-back" href="../../../container/container_methods/cos.html#ivy.container.container_methods.cos">[docs]</a><span class="k">def</span> <span class="nf">cos</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cos.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.cos also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the cosine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., -1, 1]), b=ivy.array([1., 0., -6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cos()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 0.54, 0.54]),</span>
<span class="sd">        b: ivy.array([0.54, 1., 0.96])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_bitwise_or"><a class="viewcode-back" href="../../../container/container_methods/static_bitwise_or.html#ivy.container.container_methods.static_bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_or</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_or. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.bitwise_or also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_bitwise_or(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 7]),</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), \</span>
<span class="sd">                        b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                        b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_bitwise_or(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 7]),</span>
<span class="sd">        b: ivy.array([7, 7, 7])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_or"><a class="viewcode-back" href="../../../container/container_methods/bitwise_or.html#ivy.container.container_methods.bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">bitwise_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_or. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.bitwise_or also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), \</span>
<span class="sd">                            b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4, 5, 6]), \</span>
<span class="sd">                            b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.bitwise_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([5, 7, 7]),</span>
<span class="sd">        b: ivy.array([7, 7, 7])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_bitwise_right_shift"><a class="viewcode-back" href="../../../container/container_methods/static_bitwise_right_shift.html#ivy.container.container_methods.static_bitwise_right_shift">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_right_shift</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.Container(a = ivy.array([2, 3, 4]), b = ivy.array([5, 10, 64]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_bitwise_right_shift(a, b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 1, 1]),</span>
<span class="sd">        b: ivy.array([5, 5, 16])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; a = ivy.Container(a = ivy.array([2, 3, 4]), b = ivy.array([5, 10, 64]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(a = ivy.array([0, 1, 2]), b = ivy.array([2]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_bitwise_right_shift(a, b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 1, 1]),</span>
<span class="sd">        b: ivy.array([1, 2, 16])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_right_shift"><a class="viewcode-back" href="../../../container/container_methods/bitwise_right_shift.html#ivy.container.container_methods.bitwise_right_shift">[docs]</a><span class="k">def</span> <span class="nf">bitwise_right_shift</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_right_shift.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_right_shift also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.Container(a = ivy.array([2, 3, 4]), b = ivy.array([5, 10, 64]))</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.Container(a = ivy.array([0, 1, 2]), b = ivy.array([2]))</span>
<span class="sd">    &gt;&gt;&gt; y = a.bitwise_right_shift(b)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 1, 1]),</span>
<span class="sd">        b: ivy.array([1, 2, 16])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_bitwise_xor"><a class="viewcode-back" href="../../../container/container_methods/static_bitwise_xor.html#ivy.container.container_methods.static_bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">static_bitwise_xor</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.bitwise_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.bitwise_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have an integer or boolean</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="bitwise_xor"><a class="viewcode-back" href="../../../container/container_methods/bitwise_xor.html#ivy.container.container_methods.bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">bitwise_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.bitwise_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.bitwise_xor</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have an integer or</span>
<span class="sd">        boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have an integer or boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_ceil"><a class="viewcode-back" href="../../../container/container_methods/static_ceil.html#ivy.container.container_methods.static_ceil">[docs]</a><span class="k">def</span> <span class="nf">static_ceil</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.ceil.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for ivy.ceil</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the rounded result for each element in ``x``.</span>
<span class="sd">        The returned array must have the same data type as ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ceil"><a class="viewcode-back" href="../../../container/container_methods/ceil.html#ivy.container.container_methods.ceil">[docs]</a><span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.ceil.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ceil also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.5, 0.5, -1.4]),\</span>
<span class="sd">                          b=ivy.array([5.4, -3.2, 5.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.ceil()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([3., 1., -1.]),</span>
<span class="sd">        b: ivy.array([6., -3., 6.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_cosh"><a class="viewcode-back" href="../../../container/container_methods/static_cosh.html#ivy.container.container_methods.static_cosh">[docs]</a><span class="k">def</span> <span class="nf">static_cosh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle. Should</span>
<span class="sd">        have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic cosine of each element in ``x``. The</span>
<span class="sd">        returned container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cosh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.54, 1.03, 1.7]),</span>
<span class="sd">        b: ivy.array([1.54, 3.76, 1.3])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),\</span>
<span class="sd">                b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(1), b=ivy.zeros(1))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cosh(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10.1, 1.06, 3.76]),</span>
<span class="sd">        b: ivy.array([1.23, 1.52, 10.1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cosh"><a class="viewcode-back" href="../../../container/container_methods/cosh.html#ivy.container.container_methods.cosh">[docs]</a><span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cosh. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.cosh also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle. Should</span>
<span class="sd">        have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic cosine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cosh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.54, 1.03, 1.7]),</span>
<span class="sd">        b: ivy.array([1.54, 3.76, 1.3])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),\</span>
<span class="sd">                b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(1), b=ivy.zeros(1))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.cosh(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([10.1, 1.06, 3.76]),</span>
<span class="sd">        b: ivy.array([1.23, 1.52, 10.1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_divide"><a class="viewcode-back" href="../../../container/container_methods/static_divide.html#ivy.container.container_methods.static_divide">[docs]</a><span class="k">def</span> <span class="nf">static_divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.divide. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.divide also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        dividend input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2.3, 3]), b=ivy.array([2.4, 3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_divide(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12., 1.52, 2.1]),</span>
<span class="sd">        b: ivy.array([1.25, 0.333, 0.45])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../../container/container_methods/divide.html#ivy.container.container_methods.divide">[docs]</a><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.divide also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array or container. Should have a real-valued</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 2.3, 3]), b=ivy.array([2.4, 3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12., 1.52, 2.1]),</span>
<span class="sd">        b: ivy.array([1.25, 0.333, 0.45])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_equal"><a class="viewcode-back" href="../../../container/container_methods/static_equal.html#ivy.container.container_methods.static_equal">[docs]</a><span class="k">def</span> <span class="nf">static_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../container/container_methods/equal.html#ivy.container.container_methods.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12, 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12, 2.3, 3]), b=ivy.array([2.4, 3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:`ivy.Container` and :code:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 6.3]), b=ivy.array([3., 1., 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([3., 1., 0.9])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_exp"><a class="viewcode-back" href="../../../container/container_methods/static_exp.html#ivy.container.container_methods.static_exp">[docs]</a><span class="k">def</span> <span class="nf">static_exp</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.exp. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.exp also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="exp"><a class="viewcode-back" href="../../../container/container_methods/exp.html#ivy.container.container_methods.exp">[docs]</a><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.exp.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.exp also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_expm1"><a class="viewcode-back" href="../../../container/container_methods/static_expm1.html#ivy.container.container_methods.static_expm1">[docs]</a><span class="k">def</span> <span class="nf">static_expm1</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.expm1.</span>
<span class="sd">    This method simply wraps thefunction, and so the docstring</span>
<span class="sd">    for ivy.expm1 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned array must have areal-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="expm1"><a class="viewcode-back" href="../../../container/container_methods/expm1.html#ivy.container.container_methods.expm1">[docs]</a><span class="k">def</span> <span class="nf">expm1</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.expm1.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.expm1 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.5, 0.5]),\</span>
<span class="sd">                          b=ivy.array([5.4, -3.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.expm1()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([11.2, 0.649]),</span>
<span class="sd">        b: ivy.array([220., -0.959])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4., -2.]))</span>
<span class="sd">    &gt;&gt;&gt; _ = x.expm1(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([53.6, -0.865])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_floor"><a class="viewcode-back" href="../../../container/container_methods/static_floor.html#ivy.container.container_methods.static_floor">[docs]</a><span class="k">def</span> <span class="nf">static_floor</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.floor.</span>
<span class="sd">    This method simply wraps thefunction, and so the docstring for</span>
<span class="sd">    ivy.floor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``x``. The</span>
<span class="sd">        returned array must have the same data type as ``x``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="floor"><a class="viewcode-back" href="../../../container/container_methods/floor.html#ivy.container.container_methods.floor">[docs]</a><span class="k">def</span> <span class="nf">floor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.floor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.floor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned array must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2.5, 0.5, -1.4]),\</span>
<span class="sd">                          b=ivy.array([5.4, -3.2, 5.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.floor()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., -2.]),</span>
<span class="sd">        b: ivy.array([5., -4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_floor_divide"><a class="viewcode-back" href="../../../container/container_methods/static_floor_divide.html#ivy.container.container_methods.static_floor_divide">[docs]</a><span class="k">def</span> <span class="nf">static_floor_divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.floor_divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.floor_divide also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        dividend input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5., 4., 2.5]), b=ivy.array([2.3, 3.7, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_floor_divide(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 2., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:`ivy.Container` and :code:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_floor_divide(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 1., 1.]),</span>
<span class="sd">        b: ivy.array([3., 2., 2.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="floor_divide"><a class="viewcode-back" href="../../../container/container_methods/floor_divide.html#ivy.container.container_methods.floor_divide">[docs]</a><span class="k">def</span> <span class="nf">floor_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.floor_divide.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.floor_divide also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        dividend input array or container. Should have a real-valued</span>
<span class="sd">        data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([5., 4., 2.5]), b=ivy.array([2.3, 3.7, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 2., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:`ivy.Container` and :code:`ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([4., 5., 6.]), b=ivy.array([7., 8., 9.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.floor_divide(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 1., 1.]),</span>
<span class="sd">        b: ivy.array([3., 2., 2.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_greater"><a class="viewcode-back" href="../../../container/container_methods/static_greater.html#ivy.container.container_methods.static_greater">[docs]</a><span class="k">def</span> <span class="nf">static_greater</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.greater.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.greater also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array must</span>
<span class="sd">        have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                      b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                      b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_greater(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../container/container_methods/greater.html#ivy.container.container_methods.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.greater.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        divisor input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned array must</span>
<span class="sd">        have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                      b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                      b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.greater(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_greater_equal"><a class="viewcode-back" href="../../../container/container_methods/static_greater_equal.html#ivy.container.container_methods.static_greater_equal">[docs]</a><span class="k">def</span> <span class="nf">static_greater_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="greater_equal"><a class="viewcode-back" href="../../../container/container_methods/greater_equal.html#ivy.container.container_methods.greater_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this metho with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_isfinite"><a class="viewcode-back" href="../../../container/container_methods/static_isfinite.html#ivy.container.container_methods.static_isfinite">[docs]</a><span class="k">def</span> <span class="nf">static_isfinite</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isfinite.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isfinite also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``x_i`` is finite and ``False`` otherwise.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 999999999999]),\</span>
<span class="sd">                      b=ivy.array([float(&#39;-0&#39;), ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_isfinite(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="isfinite"><a class="viewcode-back" href="../../../container/container_methods/isfinite.html#ivy.container.container_methods.isfinite">[docs]</a><span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isfinite.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isfinite also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is finite and ``False`` otherwise.</span>
<span class="sd">        The returned array must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 999999999999]),\</span>
<span class="sd">                      b=ivy.array([float(&#39;-0&#39;), ivy.nan]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.isfinite()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True]),</span>
<span class="sd">        b: ivy.array([True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_isinf"><a class="viewcode-back" href="../../../container/container_methods/static_isinf.html#ivy.container.container_methods.static_isinf">[docs]</a><span class="k">def</span> <span class="nf">static_isinf</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isinf.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isinf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``x_i`` is either positive or negative infinity and ``False``</span>
<span class="sd">        otherwise. The returned array must have a data type of ``bool``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="isinf"><a class="viewcode-back" href="../../../container/container_methods/isinf.html#ivy.container.container_methods.isinf">[docs]</a><span class="k">def</span> <span class="nf">isinf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isinf.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isinf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is either positive or negative infinity and ``False``</span>
<span class="sd">        otherwise. The returned array must have a data type of ``bool``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_isnan"><a class="viewcode-back" href="../../../container/container_methods/static_isnan.html#ivy.container.container_methods.static_isnan">[docs]</a><span class="k">def</span> <span class="nf">static_isnan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.isnan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.isnan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``x_i`` is ``NaN`` and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="isnan"><a class="viewcode-back" href="../../../container/container_methods/isnan.html#ivy.container.container_methods.isnan">[docs]</a><span class="k">def</span> <span class="nf">isnan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.isnan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.isnan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the test result. An element ``out_i`` is ``True``</span>
<span class="sd">        if ``self_i`` is ``NaN`` and ``False`` otherwise.</span>
<span class="sd">        The returned array should have a data type of ``bool``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_less"><a class="viewcode-back" href="../../../container/container_methods/static_less.html#ivy.container.container_methods.static_less">[docs]</a><span class="k">def</span> <span class="nf">static_less</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.less.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">     ivy.less also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                          b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                          b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_less(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="less"><a class="viewcode-back" href="../../../container/container_methods/less.html#ivy.container.container_methods.less">[docs]</a><span class="k">def</span> <span class="nf">less</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.less.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.less also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4, 5, 6]),\</span>
<span class="sd">                          b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                          b=ivy.array([5, 6, 7]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.less(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_less_equal"><a class="viewcode-back" href="../../../container/container_methods/static_less_equal.html#ivy.container.container_methods.static_less_equal">[docs]</a><span class="k">def</span> <span class="nf">static_less_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.less_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.less_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="less_equal"><a class="viewcode-back" href="../../../container/container_methods/less_equal.html#ivy.container.container_methods.less_equal">[docs]</a><span class="k">def</span> <span class="nf">less_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.less_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.less_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    With :code:&#39;ivy.Container&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12, 3.5, 9.2]), b=ivy.array([2., 1.1, 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([12, 2.2, 4.1]), b=ivy.array([1, 0.7, 3.8]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:&#39;ivy.Container&#39; and :code:&#39;ivy.Array&#39; inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([12., 3.5, 9.2]), b=ivy.array([2., 1., 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([2., 1.1, 5.5])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.less_equal(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, False, False]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_log"><a class="viewcode-back" href="../../../container/container_methods/static_log.html#ivy.container.container_methods.static_log">[docs]</a><span class="k">def</span> <span class="nf">static_log</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the log for each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../container/container_methods/log.html#ivy.container.container_methods.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the log for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_log1p"><a class="viewcode-back" href="../../../container/container_methods/static_log1p.html#ivy.container.container_methods.static_log1p">[docs]</a><span class="k">def</span> <span class="nf">static_log1p</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log1p.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log1p also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_log1p(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.693, 1.1]),</span>
<span class="sd">        b: ivy.array([1.39, 1.61, 1.81])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 2.]), b=ivy.array([ 4., 5.1]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_log1p(x , out = x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.693, 1.1]),</span>
<span class="sd">        b: ivy.array([1.39, 1.61, 1.81])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log1p"><a class="viewcode-back" href="../../../container/container_methods/log1p.html#ivy.container.container_methods.log1p">[docs]</a><span class="k">def</span> <span class="nf">log1p</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log1p.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log1p also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1.6, 2.6, 3.5]),\</span>
<span class="sd">                        b=ivy.array([4.5, 5.3, 2.3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.log1p()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.956, 1.28, 1.5]),</span>
<span class="sd">        b: ivy.array([1.7, 1.84, 1.19])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_log2"><a class="viewcode-back" href="../../../container/container_methods/static_log2.html#ivy.container.container_methods.static_log2">[docs]</a><span class="k">def</span> <span class="nf">static_log2</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log2 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``2`` logarithm for</span>
<span class="sd">        each element in ``x``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log2"><a class="viewcode-back" href="../../../container/container_methods/log2.html#ivy.container.container_methods.log2">[docs]</a><span class="k">def</span> <span class="nf">log2</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log2.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log2 also applies to this metho with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``2`` logarithm for each</span>
<span class="sd">        element in ``self``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_log10"><a class="viewcode-back" href="../../../container/container_methods/static_log10.html#ivy.container.container_methods.static_log10">[docs]</a><span class="k">def</span> <span class="nf">static_log10</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.log10.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log10 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``10`` logarithm for each</span>
<span class="sd">        element in ``x``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, float(&#39;nan&#39;)]),\</span>
<span class="sd">                          b=ivy.array([-0., -3.9, float(&#39;+inf&#39;)]),\</span>
<span class="sd">                          c=ivy.array([7.9, 1.1, 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_log10(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-inf, nan]),</span>
<span class="sd">        b: ivy.array([-inf, nan, inf]),</span>
<span class="sd">        c: ivy.array([0.898, 0.0414, 0.])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="log10"><a class="viewcode-back" href="../../../container/container_methods/log10.html#ivy.container.container_methods.log10">[docs]</a><span class="k">def</span> <span class="nf">log10</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.log10.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.log10 also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated base ``10`` logarithm for</span>
<span class="sd">        each element in ``self``. The returned array must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, float(&#39;nan&#39;)]), \</span>
<span class="sd">                          b=ivy.array([-0., -3.9, float(&#39;+inf&#39;)]), \</span>
<span class="sd">                          c=ivy.array([7.9, 1.1, 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.log10()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-inf, nan]),</span>
<span class="sd">        b: ivy.array([-inf, nan, inf]),</span>
<span class="sd">        c: ivy.array([0.898, 0.0414, 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_logaddexp"><a class="viewcode-back" href="../../../container/container_methods/static_logaddexp.html#ivy.container.container_methods.static_logaddexp">[docs]</a><span class="k">def</span> <span class="nf">static_logaddexp</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a real-valued floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4., 5., .]),\</span>
<span class="sd">                          b=ivy.array([2., 3., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">                          b=ivy.array([5., 6., 7.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logaddexp(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4.05, 5.05, 6.05]),</span>
<span class="sd">        b: ivy.array([5.05, 6.05, 7.05])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logaddexp"><a class="viewcode-back" href="../../../container/container_methods/logaddexp.html#ivy.container.container_methods.logaddexp">[docs]</a><span class="k">def</span> <span class="nf">logaddexp</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.greater_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.greater_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a real-valued floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` input:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4., 5., 6.]),\</span>
<span class="sd">                          b=ivy.array([2., 3., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">                          b=ivy.array([5., 6., 7.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.logaddexp(y,x)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4.05, 5.05, 6.05]),</span>
<span class="sd">        b: ivy.array([5.05, 6.05, 7.05])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_logical_and"><a class="viewcode-back" href="../../../container/container_methods/static_logical_and.html#ivy.container.container_methods.static_logical_and">[docs]</a><span class="k">def</span> <span class="nf">static_logical_and</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using &#39;ivy.Container&#39; instance</span>

<span class="sd">    &gt;&gt;&gt; i = ivy.Container(a=ivy.array([True, False, True, False]))</span>
<span class="sd">    &gt;&gt;&gt; j = ivy.Container(a=ivy.array([True, True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.Container(a=ivy.array([True, False, True]), \</span>
<span class="sd">        b=ivy.array([True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; l = ivy.Container(a=ivy.array([True, True, True]), \</span>
<span class="sd">        b=ivy.array([False, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.array([False, True, False, True])</span>
<span class="sd">    &gt;&gt;&gt; n = ivy.array([True, False, True, False])</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container.static_logical_and(i, j)</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container.static_logical_and(j, m)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_logical_and(m, n)</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_and(k, l)</span>

<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">        ivy.array([False, False, False, False])</span>

<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True]),</span>
<span class="sd">        b: ivy.array([False, False, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_and"><a class="viewcode-back" href="../../../container/container_methods/logical_and.html#ivy.container.container_methods.logical_and">[docs]</a><span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_and.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_and also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using &#39;ivy.Container&#39; instance</span>

<span class="sd">    &gt;&gt;&gt; i = ivy.Container(a=ivy.array([True, False, True, False]))</span>
<span class="sd">    &gt;&gt;&gt; j = ivy.Container(a=ivy.array([True, True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; k = ivy.Container(a=ivy.array([True, False, True]), \</span>
<span class="sd">        b=ivy.array([True, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; l = ivy.Container(a=ivy.array([True, True, True]), \</span>
<span class="sd">        b=ivy.array([False, False, False]))</span>
<span class="sd">    &gt;&gt;&gt; m = ivy.array([False, True, False, True])</span>
<span class="sd">    &gt;&gt;&gt; n = ivy.array([True, False, True, False])</span>

<span class="sd">    &gt;&gt;&gt; w = i.logical_and(j)</span>
<span class="sd">    &gt;&gt;&gt; x = j.logical_and(m)</span>
<span class="sd">    &gt;&gt;&gt; y = m.logical_and(n)</span>
<span class="sd">    &gt;&gt;&gt; z = k.logical_and(l)</span>

<span class="sd">    &gt;&gt;&gt; print(w)</span>
<span class="sd">    {a:ivy.array([True,False,False,False])}</span>

<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {a:ivy.array([False,True,False,False])}</span>

<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">        ivy.array([False, False, False, False])</span>

<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {a:ivy.array([True,False,True]),b:ivy.array([False,False,False])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_logical_not"><a class="viewcode-back" href="../../../container/container_methods/static_logical_not.html#ivy.container.container_methods.static_logical_not">[docs]</a><span class="k">def</span> <span class="nf">static_logical_not</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_not.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_not also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have a data type of ``bool``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_not"><a class="viewcode-back" href="../../../container/container_methods/logical_not.html#ivy.container.container_methods.logical_not">[docs]</a><span class="k">def</span> <span class="nf">logical_not</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_not.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_not also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have a data type of ``bool``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_logical_or"><a class="viewcode-back" href="../../../container/container_methods/static_logical_or.html#ivy.container.container_methods.static_logical_or">[docs]</a><span class="k">def</span> <span class="nf">static_logical_or</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_or.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_or also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([False, False, True]), \</span>
<span class="sd">                        b=ivy.array([True, False, True]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([False, True, False]), \</span>
<span class="sd">                            b=ivy.array([True, True, False]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_or(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, True]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_or"><a class="viewcode-back" href="../../../container/container_methods/logical_or.html#ivy.container.container_methods.logical_or">[docs]</a><span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_or.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_or also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    This function conforms to the `Array API Standard</span>
<span class="sd">    &lt;https://data-apis.org/array-api/latest/&gt;`_. This docstring is an extension of the</span>
<span class="sd">    `docstring &lt;https://data-apis.org/array-api/latest/API_specification/generated/signatures.elementwise_functions.logical_or.html&gt;`_ </span>
<span class="sd">    in the standard.</span>

<span class="sd">    Both the description and the type hints above assumes an array input for simplicity,</span>
<span class="sd">    but this function is *nestable*, and therefore also accepts :code:`ivy.Container`</span>
<span class="sd">    instances in place of any of the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([False,True,True]), b=ivy.array([3.14, 2.718, 1.618]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0, 5.2, 0.8]), b=ivy.array([0.2, 0, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_or(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([False, True, True]),</span>
<span class="sd">        b: ivy.array([True, True, True])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_logical_xor"><a class="viewcode-back" href="../../../container/container_methods/static_logical_xor.html#ivy.container.container_methods.static_logical_xor">[docs]</a><span class="k">def</span> <span class="nf">static_logical_xor</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.logical_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0,0,1,1,0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1,0,0,1,0]), b=ivy.array([1,0,1,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_xor(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True, False, False]),</span>
<span class="sd">        b: ivy.array([True, False, False, True, False])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1,0,0,1,0]), b=ivy.array([1,0,1,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0,0,1,1,0]), b=ivy.array([1,0,1,1,0]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_logical_xor(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False, True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="logical_xor"><a class="viewcode-back" href="../../../container/container_methods/logical_xor.html#ivy.container.container_methods.logical_xor">[docs]</a><span class="k">def</span> <span class="nf">logical_xor</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.logical_xor.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.logical_xor also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a boolean data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1,0,0,1,0]), b=ivy.array([1,0,1,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0,0,1,1,0]), b=ivy.array([1,0,1,1,0]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.logical_xor(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, False, True, False, False]),</span>
<span class="sd">        b: ivy.array([False, False, False, True, False])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_multiply"><a class="viewcode-back" href="../../../container/container_methods/static_multiply.html#ivy.container.container_methods.static_multiply">[docs]</a><span class="k">def</span> <span class="nf">static_multiply</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.multiply.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.multiply also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../../container/container_methods/multiply.html#ivy.container.container_methods.multiply">[docs]</a><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.multiply.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.multiply also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_negative"><a class="viewcode-back" href="../../../container/container_methods/static_negative.html#ivy.container.container_methods.static_negative">[docs]</a><span class="k">def</span> <span class="nf">static_negative</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.negative.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.negative also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="negative"><a class="viewcode-back" href="../../../container/container_methods/negative.html#ivy.container.container_methods.negative">[docs]</a><span class="k">def</span> <span class="nf">negative</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.negative.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.negative also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_not_equal"><a class="viewcode-back" href="../../../container/container_methods/static_not_equal.html#ivy.container.container_methods.static_not_equal">[docs]</a><span class="k">def</span> <span class="nf">static_not_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.not_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.not_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="not_equal"><a class="viewcode-back" href="../../../container/container_methods/not_equal.html#ivy.container.container_methods.not_equal">[docs]</a><span class="k">def</span> <span class="nf">not_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.not_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.not_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. May have any data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        May have any data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type of ``bool``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_positive"><a class="viewcode-back" href="../../../container/container_methods/static_positive.html#ivy.container.container_methods.static_positive">[docs]</a><span class="k">def</span> <span class="nf">static_positive</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.positive.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.positive also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="positive"><a class="viewcode-back" href="../../../container/container_methods/positive.html#ivy.container.container_methods.positive">[docs]</a><span class="k">def</span> <span class="nf">positive</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.positive.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.positive also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_pow"><a class="viewcode-back" href="../../../container/container_methods/static_pow.html#ivy.container.container_methods.static_pow">[docs]</a><span class="k">def</span> <span class="nf">static_pow</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.pow. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.pow also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="pow"><a class="viewcode-back" href="../../../container/container_methods/pow.html#ivy.container.container_methods.pow">[docs]</a><span class="k">def</span> <span class="nf">pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.pow. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.pow also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have a data type determined by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_remainder"><a class="viewcode-back" href="../../../functional/ivy/elementwise/remainder/static_remainder_container.html#ivy.container.container_methods.static_remainder">[docs]</a><span class="k">def</span> <span class="nf">static_remainder</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">modulus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.remainder.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.remainder also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    modulus</span>
<span class="sd">        whether to compute the modulus instead of the remainder. Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have the same sign as the respective element ``x2_i``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 3., 4.]), b=ivy.array([1., 3., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_remainder(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1.]),</span>
<span class="sd">        b: ivy.array([0., 2., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:`ivy.Container` and `ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_remainder(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:`ivy.Container` and `ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_remainder(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="remainder"><a class="viewcode-back" href="../../../container/container_methods/remainder.html#ivy.container.container_methods.remainder">[docs]</a><span class="k">def</span> <span class="nf">remainder</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">modulus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.remainder.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.remainder also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a real-valued data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`).</span>
<span class="sd">        Should have a real-valued data type.</span>
<span class="sd">    modulus</span>
<span class="sd">        whether to compute the modulus instead of the remainder. Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise results. The returned container</span>
<span class="sd">        must have the same sign as the respective element ``x2_i``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.array([1., 3., 4.]), b=ivy.array([1., 3., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1.]),</span>
<span class="sd">        b: ivy.array([0., 2., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:`ivy.Container` and `ivy.Array` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>

<span class="sd">    With mixed :code:`ivy.Container` and `ivy.NativeArray` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([2., 3., 5.]), b=ivy.array([2., 2., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.native_array([1., 2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.remainder(x2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([0., 0., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_round"><a class="viewcode-back" href="../../../container/container_methods/static_round.html#ivy.container.container_methods.static_round">[docs]</a><span class="k">def</span> <span class="nf">static_round</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.round. This method simply</span>
<span class="sd">    wraps thevfunction, and so the docstring for ivy.round also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4.20, 8.6, 6.90, 0.0]),\</span>
<span class="sd">                b=ivy.array([-300.9, -527.3, 4.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_round(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4., 9., 7., 0.]),</span>
<span class="sd">        b: ivy.array([-301., -527., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="round"><a class="viewcode-back" href="../../../container/container_methods/round.html#ivy.container.container_methods.round">[docs]</a><span class="k">def</span> <span class="nf">round</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.round. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.round also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4.20, 8.6, 6.90, 0.0]),\</span>
<span class="sd">                b=ivy.array([-300.9, -527.3, 4.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.round()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([4., 9., 7., 0.]),</span>
<span class="sd">        b: ivy.array([-301., -527., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_sign"><a class="viewcode-back" href="../../../container/container_methods/static_sign.html#ivy.container.container_methods.static_sign">[docs]</a><span class="k">def</span> <span class="nf">static_sign</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sign. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sign also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, -1., 6.6]),\</span>
<span class="sd">                        b=ivy.array([-14.2, 8.3, 0.1, -0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sign(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., -1., 1.]),</span>
<span class="sd">        b: ivy.array([-1., 1., 1., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sign"><a class="viewcode-back" href="../../../container/container_methods/sign.html#ivy.container.container_methods.sign">[docs]</a><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sign. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sign also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the evaluated result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-6.7, 2.4, -8.5]),\</span>
<span class="sd">                          b=ivy.array([1.5, -0.3, 0]),\</span>
<span class="sd">                          c=ivy.array([-4.7, -5.4, 7.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sign()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1., 1., -1.]),</span>
<span class="sd">        b: ivy.array([1., -1., 0.]),</span>
<span class="sd">        c: ivy.array([-1., -1., 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_sin"><a class="viewcode-back" href="../../../container/container_methods/static_sin.html#ivy.container.container_methods.static_sin">[docs]</a><span class="k">def</span> <span class="nf">static_sin</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sin also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the sine of each element in ``x``. The returned</span>
<span class="sd">        container must have a floating-point data type determined by</span>
<span class="sd">        :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1., -2., -3.]),\</span>
<span class="sd">                          b=ivy.array([4., 5., 6.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sin(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0.841, -0.909, -0.141]),</span>
<span class="sd">        b: ivy.array([-0.757, -0.959, -0.279])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sin"><a class="viewcode-back" href="../../../container/container_methods/sin.html#ivy.container.container_methods.sin">[docs]</a><span class="k">def</span> <span class="nf">sin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.sin also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements are each expressed in radians.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the sine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">                          b=ivy.array([-4., -5., -6.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sin()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.841, 0.909, 0.141]),</span>
<span class="sd">        b: ivy.array([0.757, 0.959, 0.279])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_sinh"><a class="viewcode-back" href="../../../container/container_methods/static_sinh.html#ivy.container.container_methods.static_sinh">[docs]</a><span class="k">def</span> <span class="nf">static_sinh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic sine of each element in ``x``.</span>
<span class="sd">        The returned container must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sinh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.18, 0.232, 1.37]),</span>
<span class="sd">        b: ivy.array([1.18, -3.63, 0.835])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),\</span>
<span class="sd">                b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(1), b=ivy.zeros(1))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_sinh(x, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-10., 0.347, 3.63]),</span>
<span class="sd">        b: ivy.array([0.721, -1.14, -10.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sinh"><a class="viewcode-back" href="../../../container/container_methods/sinh.html#ivy.container.container_methods.sinh">[docs]</a><span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sinh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sinh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an container containing the hyperbolic sine of each element in ``self``.</span>
<span class="sd">        The returned container must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-1, 0.23, 1.12]), b=ivy.array([1, -2, 0.76]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sinh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.18, 0.232, 1.37]),</span>
<span class="sd">        b: ivy.array([1.18, -3.63, 0.835])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-3, 0.34, 2.]),\</span>
<span class="sd">                b=ivy.array([0.67, -0.98, -3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.zeros(1), b=ivy.zeros(1))</span>
<span class="sd">    &gt;&gt;&gt; x.sinh(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-10., 0.347, 3.63]),</span>
<span class="sd">        b: ivy.array([0.721, -1.14, -10.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_square"><a class="viewcode-back" href="../../../container/container_methods/static_square.html#ivy.container.container_methods.static_square">[docs]</a><span class="k">def</span> <span class="nf">static_square</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.square.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.square also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square of each element in ``x``.</span>
<span class="sd">        The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../container/container_methods/square.html#ivy.container.container_methods.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.square.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.square also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square of each element in ``self``.</span>
<span class="sd">        The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_sqrt"><a class="viewcode-back" href="../../../container/container_methods/static_sqrt.html#ivy.container.container_methods.static_sqrt">[docs]</a><span class="k">def</span> <span class="nf">static_sqrt</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sqrt.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sqrt also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square root of each element in ``x``.</span>
<span class="sd">        The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../container/container_methods/sqrt.html#ivy.container.container_methods.sqrt">[docs]</a><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sqrt.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.sqrt also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the square root of each element in</span>
<span class="sd">        ``self``. The returned container must have a real-valued</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_subtract"><a class="viewcode-back" href="../../../container/container_methods/static_subtract.html#ivy.container.container_methods.static_subtract">[docs]</a><span class="k">def</span> <span class="nf">static_subtract</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.subtract.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.subtract also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``x1``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../functional/ivy/elementwise/subtract/subtract_container.html#ivy.container.container_methods.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.subtract.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.subtract also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array or container. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the element-wise sums.</span>
<span class="sd">        The returned container must have a data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_tan"><a class="viewcode-back" href="../../../container/container_methods/static_tan.html#ivy.container.container_methods.static_tan">[docs]</a><span class="k">def</span> <span class="nf">static_tan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.tan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array whose elements are expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the tangent of each element in ``x``.</span>
<span class="sd">        The return must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_tan(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1.56, -2.19]),</span>
<span class="sd">        b: ivy.array([-0.143, 1.16, -3.38])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tan"><a class="viewcode-back" href="../../../container/container_methods/tan.html#ivy.container.container_methods.tan">[docs]</a><span class="k">def</span> <span class="nf">tan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.tan.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tan also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array whose elements are expressed in radians. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the tangent of each element in ``self``.</span>
<span class="sd">        The return must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.tan()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array([0., 1.56, -2.19]),</span>
<span class="sd">        b:ivy.array([-0.143, 1.16, -3.38])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_tanh"><a class="viewcode-back" href="../../../container/container_methods/static_tanh.html#ivy.container.container_methods.static_tanh">[docs]</a><span class="k">def</span> <span class="nf">static_tanh</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.tanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the hyperbolic tangent of each element in ``x``.</span>
<span class="sd">        The returned array must have a real-valued floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_tanh(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.76, 0.96]),</span>
<span class="sd">        b: ivy.array([0.995, 0.999, 0.9999])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tanh"><a class="viewcode-back" href="../../../container/container_methods/tanh.html#ivy.container.container_methods.tanh">[docs]</a><span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.tanh.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.tanh also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container whose elements each represent a hyperbolic angle.</span>
<span class="sd">        Should have a real-valued floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the hyperbolic tangent of each element in</span>
<span class="sd">        ``self``. The returned container must have a real-valued floating-point</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.tanh()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array([0., 0.762, 0.964]),</span>
<span class="sd">        b:ivy.array([0.995, 0.999, 1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_trunc"><a class="viewcode-back" href="../../../container/container_methods/static_trunc.html#ivy.container.container_methods.static_trunc">[docs]</a><span class="k">def</span> <span class="nf">static_trunc</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.trunc.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.trunc also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``x``.</span>
<span class="sd">        The returned container must have the same data type as ``x``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="trunc"><a class="viewcode-back" href="../../../container/container_methods/trunc.html#ivy.container.container_methods.trunc">[docs]</a><span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.trunc.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.trunc also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a real-valued data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the rounded result for each element in ``self``.</span>
<span class="sd">        The returned container must have the same data type as ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_erf"><a class="viewcode-back" href="../../../container/container_methods/static_erf.html#ivy.container.container_methods.static_erf">[docs]</a><span class="k">def</span> <span class="nf">static_erf</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.erf.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.erf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to compute exponential for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Gauss error of ``x``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="erf"><a class="viewcode-back" href="../../../container/container_methods/erf.html#ivy.container.container_methods.erf">[docs]</a><span class="k">def</span> <span class="nf">erf</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.erf.</span>
<span class="sd">    This method simply wraps thefunction, and so the docstring for</span>
<span class="sd">    ivy.erf also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container to compute exponential for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Gauss error of ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_minimum"><a class="viewcode-back" href="../../../container/container_methods/static_minimum.html#ivy.container.container_methods.static_minimum">[docs]</a><span class="k">def</span> <span class="nf">static_minimum</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.minimum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.minimum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        Input array containing elements to minimum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        The other container or number to compute the minimum against.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object with all sub-arrays having the minimum values computed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="minimum"><a class="viewcode-back" href="../../../container/container_methods/minimum.html#ivy.container.container_methods.minimum">[docs]</a><span class="k">def</span> <span class="nf">minimum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.minimum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.minimum also applies to this method with minimal changes.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to minimum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        The other container or number to compute the minimum against.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object with all sub-arrays having the minimum values computed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_maximum"><a class="viewcode-back" href="../../../container/container_methods/static_maximum.html#ivy.container.container_methods.static_maximum">[docs]</a><span class="k">def</span> <span class="nf">static_maximum</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.maximum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.maximum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        Input array containing elements to maximum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing maximum values, must be broadcastable to x1.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not be lower than the x2</span>
<span class="sd">        values.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="maximum"><a class="viewcode-back" href="../../../container/container_methods/maximum.html#ivy.container.container_methods.maximum">[docs]</a><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.maximum.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.maximum also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to maximum threshold.</span>
<span class="sd">    x2</span>
<span class="sd">        Tensor containing maximum values, must be broadcastable to x1.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the elements of x1, but clipped to not be lower than the x2</span>
<span class="sd">        values.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.general</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span>

<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_is_native_array"><a class="viewcode-back" href="../../../container/container_methods/static_is_native_array.html#ivy.container.container_methods.static_is_native_array">[docs]</a><span class="k">def</span> <span class="nf">static_is_native_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_native_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_native_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is a native array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_native_array"><a class="viewcode-back" href="../../../container/container_methods/is_native_array.html#ivy.container.container_methods.is_native_array">[docs]</a><span class="k">def</span> <span class="nf">is_native_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_native_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_native_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is a native array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_ivy_array"><a class="viewcode-back" href="../../../container/container_methods/static_is_ivy_array.html#ivy.container.container_methods.static_is_ivy_array">[docs]</a><span class="k">def</span> <span class="nf">static_is_ivy_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_ivy_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_ivy_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_ivy_array"><a class="viewcode-back" href="../../../container/container_methods/is_ivy_array.html#ivy.container.container_methods.is_ivy_array">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_native_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_native_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_array"><a class="viewcode-back" href="../../../container/container_methods/static_is_array.html#ivy.container.container_methods.static_is_array">[docs]</a><span class="k">def</span> <span class="nf">static_is_array</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_array"><a class="viewcode-back" href="../../../functional/ivy/general/is_array/is_array_container.html#ivy.container.container_methods.is_array">[docs]</a><span class="k">def</span> <span class="nf">is_array</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_array.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_array also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively an array, rather than a</span>
<span class="sd">        variable or traced array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_ivy_container"><a class="viewcode-back" href="../../../container/container_methods/static_is_ivy_container.html#ivy.container.container_methods.static_is_ivy_container">[docs]</a><span class="k">def</span> <span class="nf">static_is_ivy_container</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_ivy_container.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.ivy.is_ivy_container also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input to check</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_ivy_container"><a class="viewcode-back" href="../../../container/container_methods/is_ivy_container.html#ivy.container.container_methods.is_ivy_container">[docs]</a><span class="k">def</span> <span class="nf">is_ivy_container</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_ivy_container.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.is_ivy_container also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The input to check</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a shape that the</span>
<span class="sd">        inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not x is an ivy container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_clip_vector_norm"><a class="viewcode-back" href="../../../container/container_methods/static_clip_vector_norm.html#ivy.container.container_methods.static_clip_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">static_clip_vector_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip_vector_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_vector_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        float, the maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        optional float, the p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_clip_vector_norm(x, 2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.894, 1.79]),</span>
<span class="sd">        b: ivy.array([0.849, 1.13, 1.41])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="clip_vector_norm"><a class="viewcode-back" href="../../../container/container_methods/clip_vector_norm.html#ivy.container.container_methods.clip_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip_vector_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_vector_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array</span>
<span class="sd">    max_norm</span>
<span class="sd">        float, the maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        optional float, the p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_vector_norm(2.0, 1.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0.667, 1.33]),</span>
<span class="sd">        b: ivy.array([0.5, 0.667, 0.833])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_inplace_update"><a class="viewcode-back" href="../../../container/container_methods/static_inplace_update.html#ivy.container.container_methods.static_inplace_update">[docs]</a><span class="k">def</span> <span class="nf">static_inplace_update</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_update. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_update</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to be updated inplace</span>
<span class="sd">    val</span>
<span class="sd">        value to update the input container with</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="inplace_update"><a class="viewcode-back" href="../../../container/container_methods/inplace_update.html#ivy.container.container_methods.inplace_update">[docs]</a><span class="k">def</span> <span class="nf">inplace_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_update. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_update</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container to be updated inplace</span>
<span class="sd">    val</span>
<span class="sd">        value to update the input container with</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the vector norm downscaled to the max norm if needed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_inplace_decrement"><a class="viewcode-back" href="../../../container/container_methods/static_inplace_decrement.html#ivy.container.container_methods.static_inplace_decrement">[docs]</a><span class="k">def</span> <span class="nf">static_inplace_decrement</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.inplace_decrement. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_decrement</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input array to be decremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of decrement.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place decrement.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Decrement by a value</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.5, -5., 30.]), \</span>
<span class="sd">                          b=ivy.array([0., -25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.inplace_decrement(x, 1.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1., -6.5, 28.5]),</span>
<span class="sd">        b: ivy.array([-1.5, -26.5, 48.5])</span>
<span class="sd">    }</span>

<span class="sd">    Decrement by a Container</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 15., 30.]), b=ivy.array([0., 25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 15., 30.]), b=ivy.array([0., 25., 50.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.inplace_decrement(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 0.]),</span>
<span class="sd">        b: ivy.array([0., 0., 0.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([3., 7., 10.]), b=ivy.array([0., 75., 5.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([2., 5.5, 7.]), b=ivy.array([0., 25., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.inplace_decrement(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 1.5, 3.]),</span>
<span class="sd">        b: ivy.array([0., 50., 3.5])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="inplace_decrement"><a class="viewcode-back" href="../../../container/container_methods/inplace_decrement.html#ivy.container.container_methods.inplace_decrement">[docs]</a><span class="k">def</span> <span class="nf">inplace_decrement</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_decrement. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_decrement</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply an in-place decrement.</span>
<span class="sd">    val</span>
<span class="sd">        The value of decrement.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the array following the in-place decrement.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Using :code:`ivy.Container` instance method:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([-6.7, 2.4, -8.5]),\</span>
<span class="sd">                           b=ivy.array([1.5, -0.3, 0]),\</span>
<span class="sd">                           c=ivy.array([-4.7, -5.4, 7.5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.inplace_decrement(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-8.7, 0.4, -10.5]),</span>
<span class="sd">        b: ivy.array([-0.5, -2.3, -2]),</span>
<span class="sd">        c: ivy.array([-6.7, -7.4, 5.5])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_inplace_increment"><a class="viewcode-back" href="../../../container/container_methods/static_inplace_increment.html#ivy.container.container_methods.static_inplace_increment">[docs]</a><span class="k">def</span> <span class="nf">static_inplace_increment</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.inplace_increment. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_increment</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The input array to be decremented by the defined value.</span>
<span class="sd">    val</span>
<span class="sd">        The value of increment.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The array following an in-place increment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="inplace_increment"><a class="viewcode-back" href="../../../container/container_methods/inplace_increment.html#ivy.container.container_methods.inplace_increment">[docs]</a><span class="k">def</span> <span class="nf">inplace_increment</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.inplace_increment. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.inplace_increment</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply an in-place increment.</span>
<span class="sd">    val</span>
<span class="sd">        The value of decrement.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the array following the in-place increment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_supports_inplace_update"><a class="viewcode-back" href="../../../container/container_methods/static_supports_inplace_update.html#ivy.container.container_methods.static_supports_inplace_update">[docs]</a><span class="k">def</span> <span class="nf">static_supports_inplace_update</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.supports_inplace_update. This</span>
<span class="sd">    method simply wrapsthe function, and so the docstring for</span>
<span class="sd">    ivy.supports_inplace_update also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to check for inplace support for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of whether or not inplace operations are supported for x and</span>
<span class="sd">        its leaves.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="supports_inplace_update"><a class="viewcode-back" href="../../../container/container_methods/supports_inplace_update.html#ivy.container.container_methods.supports_inplace_update">[docs]</a><span class="k">def</span> <span class="nf">supports_inplace_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.supports_inplace_update. This</span>
<span class="sd">    method simply wrapsthe function, and so the docstring for</span>
<span class="sd">    ivy.supports_inplace_update also applies to this methodwith minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to check for inplace support for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        True if support, raises exception otherwise`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_assert_supports_inplace"><a class="viewcode-back" href="../../../container/container_methods/static_assert_supports_inplace.html#ivy.container.container_methods.static_assert_supports_inplace">[docs]</a><span class="k">def</span> <span class="nf">static_assert_supports_inplace</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.assert_supports_inplace. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.assert_supports_inplace also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to check for inplace support for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        True if support, raises exception otherwise`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="assert_supports_inplace"><a class="viewcode-back" href="../../../container/container_methods/assert_supports_inplace.html#ivy.container.container_methods.assert_supports_inplace">[docs]</a><span class="k">def</span> <span class="nf">assert_supports_inplace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.assert_supports_inplace. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.assert_supports_inplace also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to check for inplace support for.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of whether or not inplace operations are supported for x and</span>
<span class="sd">        its leaves.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_all_equal"><a class="viewcode-back" href="../../../container/container_methods/static_all_equal.html#ivy.container.container_methods.static_all_equal">[docs]</a><span class="k">def</span> <span class="nf">static_all_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
    <span class="n">equality_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.all_equal. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.all_equal also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        input container.</span>
<span class="sd">    x2</span>
<span class="sd">        array or container to be compared to ``x1``.</span>
<span class="sd">    equality_matrix</span>
<span class="sd">        Whether to return a matrix of equalities comparing each input with every</span>
<span class="sd">        other. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the inputs are equal, or matrix container of</span>
<span class="sd">        booleans if equality_matrix=True is set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]), b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True, True]),</span>
<span class="sd">        b: ivy.array([True, False, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]), \</span>
<span class="sd">                            b=ivy.native_array([1, 0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.native_array([1, 0, 1, 1]), \</span>
<span class="sd">                            b=ivy.array([1, 0, -1, -1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([True, True, True, True]),</span>
<span class="sd">        b: ivy.array([True, True, False, False])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="all_equal"><a class="viewcode-back" href="../../../container/container_methods/all_equal.html#ivy.container.container_methods.all_equal">[docs]</a><span class="k">def</span> <span class="nf">all_equal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
    <span class="n">equality_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.all_equal.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.all_equal also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    x2</span>
<span class="sd">        array or container to be compared to ``self``.</span>
<span class="sd">    equality_matrix</span>
<span class="sd">        Whether to return a matrix of equalities comparing each input with every</span>
<span class="sd">        other. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, whether or not the inputs are equal, or matrix container of</span>
<span class="sd">        booleans if equality_matrix=True is set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]), b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = x1.all_equal(x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.array([1, 0, 1, 1]), b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.array([1, 0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.native_array([1, 0, 0]),\</span>
<span class="sd">                            b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.native_array([1, 0, 1]),\</span>
<span class="sd">                            b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x1.all_equal(x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x1 = ivy.Container(a=ivy.native_array([1, 0, 0]),\</span>
<span class="sd">                            b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; x2 = ivy.Container(a=ivy.native_array([1, 0, 1]),\</span>
<span class="sd">                            b=ivy.array([1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all_equal(x1, x2, equality_matrix= False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_unstack"><a class="viewcode-back" href="../../../container/container_methods/static_unstack.html#ivy.container.container_methods.static_unstack">[docs]</a><span class="k">def</span> <span class="nf">static_unstack</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.unstack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.unstack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container to unstack.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis for which to unpack the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        Whether to keep dimension 1 in the unstack dimensions. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        List of arrays, unpacked along specified dimensions, or containers</span>
<span class="sd">        with arrays unpacked at leaves</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">                        b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_unstack(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                     [3, 4]]),</span>
<span class="sd">        b: ivy.array([[9, 10],</span>
<span class="sd">                     [11, 12]])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([[5, 6],</span>
<span class="sd">                     [7, 8]]),</span>
<span class="sd">         b: ivy.array([[13, 14],</span>
<span class="sd">                      [15, 16]])</span>
<span class="sd">    }]</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">                        b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_unstack(x, axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[[1, 2]],</span>
<span class="sd">                     [[5, 6]]]),</span>
<span class="sd">        b: ivy.array([[[9, 10]],</span>
<span class="sd">                     [[13, 14]]])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([[[3, 4]],</span>
<span class="sd">                     [[7, 8]]]),</span>
<span class="sd">        b: ivy.array([[[11, 12]],</span>
<span class="sd">                     [[15, 16]]])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="unstack"><a class="viewcode-back" href="../../../container/container_methods/unstack.html#ivy.container.container_methods.unstack">[docs]</a><span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.unstack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.unstack</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to unstack at leaves.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis for which to unpack the array.</span>
<span class="sd">    keepdims</span>
<span class="sd">        Whether to keep dimension 1 in the unstack dimensions. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Containers with arrays unpacked at leaves</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),</span>
<span class="sd">                        b=ivy.array([[[9, 10], [11, 12]], [[13, 14], [15, 16]]]))</span>
<span class="sd">    &gt;&gt;&gt; x.unstack(axis=0)</span>
<span class="sd">    [{</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                     [3, 4]]),</span>
<span class="sd">        b: ivy.array([[9, 10],</span>
<span class="sd">                      [11, 12]])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([[5, 6],</span>
<span class="sd">                      [7, 8]]),</span>
<span class="sd">        b: ivy.array([[13, 14],</span>
<span class="sd">                      [15, 16]])</span>
<span class="sd">    }]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_cumsum"><a class="viewcode-back" href="../../../container/container_methods/static_cumsum.html#ivy.container.container_methods.static_cumsum">[docs]</a><span class="k">def</span> <span class="nf">static_cumsum</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cumsum. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumsum</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container to apply cumsum.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative sum is computed. Default is 0.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to perform cumsum exclusively. Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumsum from last to first element in the selected</span>
<span class="sd">        axis. Default is False (from first to last element)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container whose leaves hold the result of applying cumsum</span>
<span class="sd">        at each original leaf arrays along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 2, 3], [2, 4, 5]]), \</span>
<span class="sd">                          b=ivy.array([[4, 5, 6], [2, 3, 1 ]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cumsum(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 2, 3],</span>
<span class="sd">                      [3, 6, 8]]),</span>
<span class="sd">        b: ivy.array([[4, 5, 6],</span>
<span class="sd">                      [6, 8, 7]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 5]]), \</span>
<span class="sd">                          b=ivy.array([[3, 5, 7]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cumsum(x, axis=0,  \</span>
<span class="sd">                          exclusive=False, reverse=True, dtype=&#39;float32&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1., 3., 5.]]),</span>
<span class="sd">        b: ivy.array([[3., 5., 7.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4]]), \</span>
<span class="sd">                          b=ivy.array([[3, 5, 8], \</span>
<span class="sd">                                       [5, 6, 5]]), \</span>
<span class="sd">                          c=ivy.array([[2, 4, 1], \</span>
<span class="sd">                                       [3, 6, 9], \</span>
<span class="sd">                                       [0, 2, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((1, 3)), \</span>
<span class="sd">                          b = ivy.zeros((2, 3)), \</span>
<span class="sd">                          c = ivy.zeros((3,3)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.cumsum(x,axis=1,exclusive=True, reverse=False, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 4]]),</span>
<span class="sd">        b: ivy.array([[0, 3, 8],</span>
<span class="sd">                      [0, 5, 11]]),</span>
<span class="sd">        c: ivy.array([[0, 2, 6],</span>
<span class="sd">                      [0, 3, 9],</span>
<span class="sd">                      [0, 0, 2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4], [5, 7, 8], [9, 10, 11]]), \</span>
<span class="sd">                          b=ivy.array([[3, 4, 5], [4, 5, 6], [5, 6, 7]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a= ivy.zeros((3, 3)), b= ivy.zeros((3, 3)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cumsum(x, axis=1, exclusive=True, reverse=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[7, 4, 0],</span>
<span class="sd">                      [15, 8, 0],</span>
<span class="sd">                      [21, 11, 0]]),</span>
<span class="sd">        b: ivy.array([[9, 5, 0],</span>
<span class="sd">                      [11, 6, 0],</span>
<span class="sd">                      [13, 7, 0]])</span>
<span class="sd">    }</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1], \</span>
<span class="sd">                                       [1]]), \</span>
<span class="sd">                      b=ivy.array([[6, 8, 7], \</span>
<span class="sd">                                   [2, 0, 1]]), \</span>
<span class="sd">                      c=ivy.array([[1, 2], \</span>
<span class="sd">                                   [3, 4], \</span>
<span class="sd">                                   [6, 4]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cumsum(x, axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1],</span>
<span class="sd">                      [2]]),</span>
<span class="sd">        b: ivy.array([[6, 8, 7],</span>
<span class="sd">                      [8, 8, 8]]),</span>
<span class="sd">        c: ivy.array([[1, 2],</span>
<span class="sd">                      [4, 6],</span>
<span class="sd">                      [10, 10]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cumsum"><a class="viewcode-back" href="../../../container/container_methods/cumsum.html#ivy.container.container_methods.cumsum">[docs]</a><span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cumsum. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumsum</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply cumsum at leaves.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative sum is computed. Default is 0.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to perform cumsum exclusively. Default is ``False``.</span>
<span class="sd">    reverse</span>
<span class="sd">        Whether to perform the cumsum from last to first element in the selected</span>
<span class="sd">        axis. Default is False (from first to last element)</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Container whose leaves hold the result of applying cumsum</span>
<span class="sd">        at each original leaf arrays along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 2, 3], \</span>
<span class="sd">                                      [2, 4, 5]]), \</span>
<span class="sd">                          b=ivy.array([[4, 5, 6], \</span>
<span class="sd">                                      [2, 3, 1 ]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=0, dtype=&#39;float64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1., 2., 3.],</span>
<span class="sd">                      [3., 6., 8.]]),</span>
<span class="sd">        b: ivy.array([[4., 5., 6.],</span>
<span class="sd">                      [6., 8., 7.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4], \</span>
<span class="sd">                                       [5, 7, 8], \</span>
<span class="sd">                                       [9, 10, 11]]), \</span>
<span class="sd">                          b=ivy.array([[3, 4, 5], \</span>
<span class="sd">                                       [4, 5, 6], \</span>
<span class="sd">                                        [5, 6, 7]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a= ivy.zeros((3, 3)), b= ivy.zeros((3, 3)))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=1, exclusive=False, reverse=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[8, 7, 4],</span>
<span class="sd">                      [20, 15, 8],</span>
<span class="sd">                      [30, 21, 11]]),</span>
<span class="sd">        b: ivy.array([[12, 9, 5],</span>
<span class="sd">                      [15, 11, 6],</span>
<span class="sd">                      [18, 13, 7]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1, 3, 4]]), \</span>
<span class="sd">                          b=ivy.array([[3, 5, 8], \</span>
<span class="sd">                                       [5, 6, 5]]), \</span>
<span class="sd">                          c=ivy.array([[2, 4, 1], \</span>
<span class="sd">                                       [3, 6, 9], \</span>
<span class="sd">                                       [0, 2, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((1, 3)), \</span>
<span class="sd">                          b = ivy.zeros((2, 3)), \</span>
<span class="sd">                          c = ivy.zeros((3,3)))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=1,exclusive=True, reverse=False, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 4]]),</span>
<span class="sd">        b: ivy.array([[0, 3, 8],</span>
<span class="sd">                      [0, 5, 11]]),</span>
<span class="sd">        c: ivy.array([[0, 2, 6],</span>
<span class="sd">                      [0, 3, 9],</span>
<span class="sd">                      [0, 0, 2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 3, 2], \</span>
<span class="sd">                                       [5, 10, 2], \</span>
<span class="sd">                                       [1, 10, 1]]), \</span>
<span class="sd">                          b=ivy.array([[2, 4, 5], \</span>
<span class="sd">                                       [4, 5, 5], \</span>
<span class="sd">                                       [0, 1, 3]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumsum(axis=1,exclusive=True, reverse=True, dtype=&#39;int64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[5, 2, 0],</span>
<span class="sd">                      [12, 2, 0],</span>
<span class="sd">                      [11, 1, 0]]),</span>
<span class="sd">        b: ivy.array([[9, 5, 0],</span>
<span class="sd">                      [10, 5, 0],</span>
<span class="sd">                      [4, 3, 0]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0], \</span>
<span class="sd">                                   [5]]), \</span>
<span class="sd">                      b=ivy.array([[6, 8, 7], \</span>
<span class="sd">                                   [4, 2, 3]]), \</span>
<span class="sd">                      c=ivy.array([[1, 2], \</span>
<span class="sd">                                   [3, 4], \</span>
<span class="sd">                                   [6, 4]]))</span>
<span class="sd">    &gt;&gt;&gt; x.cumsum(axis=0, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0],</span>
<span class="sd">                     [5]]),</span>
<span class="sd">        b: ivy.array([[6, 8, 7],</span>
<span class="sd">                     [10, 10, 10]]),</span>
<span class="sd">        c: ivy.array([[1, 2],</span>
<span class="sd">                     [4, 6],</span>
<span class="sd">                     [10, 10]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_cumprod"><a class="viewcode-back" href="../../../container/container_methods/static_cumprod.html#ivy.container.container_methods.static_cumprod">[docs]</a><span class="k">def</span> <span class="nf">static_cumprod</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cumprod. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumprod</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container to cumprod.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis to cumprod along. Default is 0.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to exclude the first element of the input array. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Containers with arrays cumprod at leaves along specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cumprod(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 6]),</span>
<span class="sd">        b: ivy.array([4, 20, 120])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[2, 3], [5, 7], [11, 13]]),</span>
<span class="sd">                          b=ivy.array([[3, 4], [4, 5], [5, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((3, 2)), b = ivy.zeros((3, 2)))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_cumprod(x, axis=1, exclusive=True, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                      [1, 5],</span>
<span class="sd">                      [1, 11]]),</span>
<span class="sd">        b: ivy.array([[1, 3],</span>
<span class="sd">                      [1, 4],</span>
<span class="sd">                      [1, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cumprod"><a class="viewcode-back" href="../../../container/container_methods/cumprod.html#ivy.container.container_methods.cumprod">[docs]</a><span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cumprod. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.cumprod</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to cumprod at leaves.</span>
<span class="sd">    axis</span>
<span class="sd">        Axis along which the cumulative product is computed. Default is 0.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to exclude the first element of the input array. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Containers with arrays cumprod at leaves along specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array([4, 5, 6]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cumprod(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 6]),</span>
<span class="sd">        b: ivy.array([4, 20, 120])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[2, 3], [5, 7], [11, 13]]),</span>
<span class="sd">                          b=ivy.array([[3, 4], [4, 5], [5, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a = ivy.zeros((3, 2)), b = ivy.zeros((3, 2)))</span>
<span class="sd">    &gt;&gt;&gt; x.cumprod(axis=1, exclusive=True, out=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1, 2],</span>
<span class="sd">                      [1, 5],</span>
<span class="sd">                      [1, 11]]),</span>
<span class="sd">        b: ivy.array([[1, 3],</span>
<span class="sd">                      [1, 4],</span>
<span class="sd">                      [1, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_fourier_encode"><a class="viewcode-back" href="../../../container/container_methods/static_fourier_encode.html#ivy.container.container_methods.static_fourier_encode">[docs]</a><span class="k">def</span> <span class="nf">static_fourier_encode</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">max_freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.fourier_encode. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.fourier_encode</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input container to apply fourier_encode.</span>
<span class="sd">    max_freq</span>
<span class="sd">        The maximum frequency of the encoding.</span>
<span class="sd">    num_bands</span>
<span class="sd">        The number of frequency bands for the encoding. Default is 4.</span>
<span class="sd">    linear</span>
<span class="sd">        Whether to space the frequency bands linearly as opposed to geometrically.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    flatten</span>
<span class="sd">        Whether to flatten the position dimension into the batch dimension.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with the final dimension expanded of arrays at its leaves,</span>
<span class="sd">        and the encodings stored in this channel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="fourier_encode"><a class="viewcode-back" href="../../../container/container_methods/fourier_encode.html#ivy.container.container_methods.fourier_encode">[docs]</a><span class="k">def</span> <span class="nf">fourier_encode</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">flatten</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.fourier_encode. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.fourier_encode</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to apply fourier_encode at leaves.</span>
<span class="sd">    max_freq</span>
<span class="sd">        The maximum frequency of the encoding.</span>
<span class="sd">    num_bands</span>
<span class="sd">        The number of frequency bands for the encoding. Default is 4.</span>
<span class="sd">    linear</span>
<span class="sd">        Whether to space the frequency bands linearly as opposed to geometrically.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    flatten</span>
<span class="sd">        Whether to flatten the position dimension into the batch dimension.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    dtype</span>
<span class="sd">        Data type of the returned array. Default is ``None``.</span>
<span class="sd">    out</span>
<span class="sd">        Optional output container. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with the final dimension expanded of arrays at its leaves,</span>
<span class="sd">        and the encodings stored in this channel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_gather"><a class="viewcode-back" href="../../../container/container_methods/static_gather.html#ivy.container.container_methods.static_gather">[docs]</a><span class="k">def</span> <span class="nf">static_gather</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform einops rearrange operation on each sub array in the container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    **axes_lengths</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.rearrange applied.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gather"><a class="viewcode-back" href="../../../container/container_methods/gather.html#ivy.container.container_methods.gather">[docs]</a><span class="k">def</span> <span class="nf">gather</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gather. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.gather also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        the container from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        index array or container</span>
<span class="sd">    axis</span>
<span class="sd">        optional int, the axis from which to gather from. Default is -1.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with the values gathered at the specified indices along</span>
<span class="sd">        the specified axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_has_nans"><a class="viewcode-back" href="../../../container/container_methods/static_has_nans.html#ivy.container.container_methods.static_has_nans">[docs]</a><span class="k">def</span> <span class="nf">static_has_nans</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.has_nans. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.has_nans also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input container.</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include ``+infinity`` and ``-infinity`` in the check.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container of booleans, whether there is a nans at indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array([1, 2, float(&#39;nan&#39;)]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_has_nans(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="has_nans"><a class="viewcode-back" href="../../../container/container_methods/has_nans.html#ivy.container.container_methods.has_nans">[docs]</a><span class="k">def</span> <span class="nf">has_nans</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.has_nans.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.has_nans also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container from which to check nans.</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include ``+infinity`` and ``-infinity`` in the check.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, true if container has a nans, false otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]), b=ivy.array([1, 2, float(&#39;nan&#39;)]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.has_nans()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: true</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_scatter_nd"><a class="viewcode-back" href="../../../container/container_methods/static_scatter_nd.html#ivy.container.container_methods.static_scatter_nd">[docs]</a><span class="k">def</span> <span class="nf">static_scatter_nd</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.scatter_nd. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.scatter_nd also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the result. Default is None, in which case tensor argument</span>
<span class="sd">        must be provided.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ref</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    scatter into an empty array</span>
<span class="sd">    &gt;&gt; indices = ivy.Container(a=ivy.array([[5],[6],[7]]),</span>
<span class="sd">                                b=ivy.array([[2],[3],[4]]))</span>
<span class="sd">    &gt;&gt; updates = ivy.Container(a=ivy.array([50, 60, 70]),</span>
<span class="sd">                                b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt; arr = ivy.Container(a=ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),</span>
<span class="sd">                            b = ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))</span>
<span class="sd">    &gt;&gt; shape = ivy.Container(a=ivy.array([10]),</span>
<span class="sd">                            b = ivy.array([10]))</span>
<span class="sd">    z = ivy.Container.static_scatter_nd(indices, updates, shape=shape)</span>
<span class="sd">    &gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 0, 0, 0, 0, 50, 60, 70, 0, 0]),</span>
<span class="sd">        b: ivy.array([0, 0, 20, 30, 40, 0, 0, 0, 0, 0])</span>
<span class="sd">    }</span>

<span class="sd">    scatter into an array</span>
<span class="sd">    &gt;&gt; indices = ivy.Container(a=ivy.array([[5],[6],[7]]),</span>
<span class="sd">              b=ivy.array([[2],[3],[4]]))</span>
<span class="sd">    &gt;&gt; updates = ivy.Container(a=ivy.array([50, 60, 70]),</span>
<span class="sd">                    b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt; arr = ivy.Container(a=ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),</span>
<span class="sd">                            b = ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))</span>

<span class="sd">    z = ivy.Container.static_scatter_nd(indices, updates,</span>
<span class="sd">                                        tensor=arr, reduction=&#39;replace&#39;)</span>
<span class="sd">    &gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 2, 3, 4, 5, 50, 60, 70, 9, 10]),</span>
<span class="sd">        b: ivy.array([1, 2, 20, 30, 40, 6, 7, 8, 9, 10])</span>
<span class="sd">    }</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="scatter_nd"><a class="viewcode-back" href="../../../container/container_methods/scatter_nd.html#ivy.container.container_methods.scatter_nd">[docs]</a><span class="k">def</span> <span class="nf">scatter_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.scatter_nd.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.scatter_nd also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    shape</span>
<span class="sd">        The shape of the result. Default is None, in which case tensor argument</span>
<span class="sd">        must be provided.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    scatter into an array</span>
<span class="sd">    &gt;&gt; indices = ivy.Container(a=ivy.array([[3],[1],[2]]),</span>
<span class="sd">                                b=ivy.array([[4],[1],[3]]))</span>
<span class="sd">    &gt;&gt; updates = ivy.Container(a=ivy.array([50, 60, 70]),</span>
<span class="sd">                                b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt; arr = ivy.Container(a=ivy.array([1, 2, 3, 4, 5]),</span>
<span class="sd">                            b=ivy.array([11, 22, 33, 44, 55]))</span>
<span class="sd">    &gt;&gt; z = indices.scatter_nd(updates, tensor=arr, reduction=&#39;replace&#39;)</span>
<span class="sd">    &gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 60, 70, 50, 5]),</span>
<span class="sd">        b: ivy.array([11, 30, 33, 40, 20])</span>
<span class="sd">    }</span>

<span class="sd">    scatter into an empty array</span>
<span class="sd">    &gt;&gt; indices = ivy.Container(a=ivy.array([[5],[6],[7]]),</span>
<span class="sd">                                b=ivy.array([[2],[3],[4]]))</span>
<span class="sd">    &gt;&gt; updates = ivy.Container(a=ivy.array([50, 60, 70]),</span>
<span class="sd">                                b=ivy.array([20, 30, 40]))</span>
<span class="sd">    &gt;&gt; arr = ivy.Container(a=ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),</span>
<span class="sd">                            b = ivy.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))</span>
<span class="sd">    &gt;&gt; shape = ivy.Container(a=ivy.array([10]),</span>
<span class="sd">                            b = ivy.array([10]))</span>
<span class="sd">    z = indices.scatter_nd(updates, shape=shape)</span>
<span class="sd">    &gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 0, 0, 0, 0, 50, 60, 70, 0, 0]),</span>
<span class="sd">        b: ivy.array([0, 0, 20, 30, 40, 0, 0, 0, 0, 0])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_scatter_flat"><a class="viewcode-back" href="../../../container/container_methods/static_scatter_flat.html#ivy.container.container_methods.static_scatter_flat">[docs]</a><span class="k">def</span> <span class="nf">static_scatter_flat</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.scatter_flat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.scatter_flat also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    size</span>
<span class="sd">        The size of the result.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ref</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="scatter_flat"><a class="viewcode-back" href="../../../container/container_methods/scatter_flat.html#ivy.container.container_methods.scatter_flat">[docs]</a><span class="k">def</span> <span class="nf">scatter_flat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.scatter_flat.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.scatter_flat also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    updates</span>
<span class="sd">        values to update input tensor with</span>
<span class="sd">    size</span>
<span class="sd">        The size of the result.</span>
<span class="sd">    reduction</span>
<span class="sd">        The reduction method for the scatter, one of &#39;sum&#39;, &#39;min&#39;, &#39;max&#39;</span>
<span class="sd">        or &#39;replace&#39;</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container of given shape, with the values updated at the indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_gather_nd"><a class="viewcode-back" href="../../../container/container_methods/static_gather_nd.html#ivy.container.container_methods.static_gather_nd">[docs]</a><span class="k">def</span> <span class="nf">static_gather_nd</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Gather slices from all container params into a arrays with shape specified by</span>
<span class="sd">    indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Index array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Container object with all sub-array dimensions gathered.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gather_nd"><a class="viewcode-back" href="../../../container/container_methods/gather_nd.html#ivy.container.container_methods.gather_nd">[docs]</a><span class="k">def</span> <span class="nf">gather_nd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gather_nd.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.gather_nd also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The container from which to gather values.</span>
<span class="sd">    indices</span>
<span class="sd">        Index array or container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc. Same as</span>
<span class="sd">        ``x`` if None.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container of given shape, with the values gathered at the indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 2, 3]),\</span>
<span class="sd">                          b=ivy.array([2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([2]),\</span>
<span class="sd">                          b=ivy.array([1]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.gather_nd(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(3),</span>
<span class="sd">        b: ivy.array(3)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_einops_reduce"><a class="viewcode-back" href="../../../container/container_methods/static_einops_reduce.html#ivy.container.container_methods.static_einops_reduce">[docs]</a><span class="k">def</span> <span class="nf">static_einops_reduce</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform einops reduce operation on each sub array in the container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Reduction pattern.</span>
<span class="sd">    reduction</span>
<span class="sd">        One of available reductions (&#39;min&#39;, &#39;max&#39;, &#39;sum&#39;, &#39;mean&#39;, &#39;prod&#39;), or</span>
<span class="sd">        callable.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    **axes_lengths</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.reduce applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt; x = ivy.Container(a=ivy.array([[[8.64, 4.83, -7.4],</span>
<span class="sd">                                       [0.735, -6.7, 13.27]],</span>
<span class="sd">                                      [[-24.037, 8.5, 26.7],</span>
<span class="sd">                                       [0.451, 12.4, 1.7]],</span>
<span class="sd">                                      [[-5.6, -18.19, -20.35],</span>
<span class="sd">                                       [2.58, -1.006, -9.973]]]),</span>
<span class="sd">                        b=ivy.array([[[-4.47, 0.93, -3.34],</span>
<span class="sd">                                      [3.66, 24.29, 3.64]],</span>
<span class="sd">                                     [[4.96, 1.52, -10.67],</span>
<span class="sd">                                      [4.36, 13.96, 0.3]]]))</span>
<span class="sd">    &gt;&gt; reduced = ivy.Container.static_einops_reduce(x, &#39;a b c -&gt; () () c&#39;, &#39;mean&#39;)</span>
<span class="sd">    &gt;&gt; print(reduced)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[-2.87, -0.0277, 0.658]]]),</span>
<span class="sd">        b: ivy.array([[[2.13, 10.2, -2.52]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einops_reduce"><a class="viewcode-back" href="../../../container/container_methods/einops_reduce.html#ivy.container.container_methods.einops_reduce">[docs]</a><span class="k">def</span> <span class="nf">einops_reduce</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">reduction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.einops_reduce. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_reduce also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container to be reduced.</span>
<span class="sd">    pattern</span>
<span class="sd">        Reduction pattern.</span>
<span class="sd">    reduction</span>
<span class="sd">        One of available reductions (&#39;min&#39;, &#39;max&#39;, &#39;sum&#39;, &#39;mean&#39;, &#39;prod&#39;), or</span>
<span class="sd">        callable.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with einops.reduce having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt; x = ivy.Container(a=ivy.array([[[5, 4, 3],</span>
<span class="sd">                                       [11, 2, 9]],</span>
<span class="sd">                                      [[3, 5, 7],</span>
<span class="sd">                                       [9, 7, 1]]]),</span>
<span class="sd">                        b=ivy.array([[[9,7,6],</span>
<span class="sd">                                      [5,2,1]],</span>
<span class="sd">                                    [[4,1,2],</span>
<span class="sd">                                     [2,3,6]],</span>
<span class="sd">                                    [[1, 9, 6],</span>
<span class="sd">                                     [0, 2, 1]]]))</span>
<span class="sd">    &gt;&gt; reduced = x.einops_reduce(&#39;a b c -&gt; a b&#39;, &#39;sum&#39;)</span>
<span class="sd">    &gt;&gt; print(reduced)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[12, 22],</span>
<span class="sd">                    [15, 17]]),</span>
<span class="sd">        b: ivy.array([[22, 8],</span>
<span class="sd">                    [7, 11],</span>
<span class="sd">                    [16, 3]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_einops_repeat"><a class="viewcode-back" href="../../../container/container_methods/static_einops_repeat.html#ivy.container.container_methods.static_einops_repeat">[docs]</a><span class="k">def</span> <span class="nf">static_einops_repeat</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform einops repeat operation on each sub array in the container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    **axes_lengths</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.repeat applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt; x = ivy.Container(a=ivy.array([[30, 40], [50, 75]]),</span>
<span class="sd">                        b=ivy.array([[1, 2], [4, 5]]))</span>
<span class="sd">    &gt;&gt; repeated = ivy.Container.static_einops_repeat(x, &#39;h w -&gt; (tile h) w&#39;, tile=2)</span>
<span class="sd">    &gt;&gt; print(repeated)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[30, 40],</span>
<span class="sd">                    [50, 75],</span>
<span class="sd">                    [30, 40],</span>
<span class="sd">                    [50, 75]]),</span>
<span class="sd">        b: ivy.array([[1, 2],</span>
<span class="sd">                    [4, 5],</span>
<span class="sd">                    [1, 2],</span>
<span class="sd">                    [4, 5]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einops_repeat"><a class="viewcode-back" href="../../../container/container_methods/einops_repeat.html#ivy.container.container_methods.einops_repeat">[docs]</a><span class="k">def</span> <span class="nf">einops_repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.einops_repeat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.einops_repeat also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array or container to be repeated.</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        New container with einops.repeat having been applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt; x = ivy.Container(a=ivy.array([[30, 40], [50, 75]]),</span>
<span class="sd">                         b=ivy.array([[1, 2], [4, 5]]))</span>
<span class="sd">    &gt;&gt; repeated = x.einops_repeat(&#39;h w -&gt;  h  (w tile)&#39;, tile=2)</span>
<span class="sd">    &gt;&gt; print(repeated)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[30, 30, 40, 40],</span>
<span class="sd">                      [50, 50, 75, 75]]),</span>
<span class="sd">        b: ivy.array([[1, 1, 2, 2],</span>
<span class="sd">                      [4, 4, 5, 5]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_to_scalar"><a class="viewcode-back" href="../../../container/container_methods/static_to_scalar.html#ivy.container.container_methods.static_to_scalar">[docs]</a><span class="k">def</span> <span class="nf">static_to_scalar</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_scalar. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_scalar also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of scalars copying the element of the array ``x``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="to_scalar"><a class="viewcode-back" href="../../../container/container_methods/to_scalar.html#ivy.container.container_methods.to_scalar">[docs]</a><span class="k">def</span> <span class="nf">to_scalar</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_scalar. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_scalar also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of scalars copying the element of the array ``self``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_value_is_nan"><a class="viewcode-back" href="../../../container/container_methods/static_value_is_nan.html#ivy.container.container_methods.static_value_is_nan">[docs]</a><span class="k">def</span> <span class="nf">static_value_is_nan</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.value_is_nan. This method simply</span>
<span class="sd">    wrapsthe function, and so the docstring for ivy.value_is_nan also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the input value is a nan or not.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="value_is_nan"><a class="viewcode-back" href="../../../container/container_methods/value_is_nan.html#ivy.container.container_methods.value_is_nan">[docs]</a><span class="k">def</span> <span class="nf">value_is_nan</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">include_infs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.value_is_nan. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.value_is_nan also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    include_infs</span>
<span class="sd">        Whether to include infs and -infs in the check. Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean as to whether the input value is a nan or not.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_to_numpy"><a class="viewcode-back" href="../../../container/container_methods/static_to_numpy.html#ivy.container.container_methods.static_to_numpy">[docs]</a><span class="k">def</span> <span class="nf">static_to_numpy</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_numpy. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_numpy also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of numpy arrays copying all the element of the container</span>
<span class="sd">        ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 1, 1]),\</span>
<span class="sd">                        b=ivy.array([1, -1, 0, 0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_to_numpy(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([1, 0, 1, 1], dtype=int32),</span>
<span class="sd">        b: array([1, -1, 0, 0], dtype=int32)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 0., 0., 1.]),\</span>
<span class="sd">                        b=ivy.native_array([1, 1, -1, 0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_to_numpy(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([1., 0., 0., 1.], dtype=float32),</span>
<span class="sd">        b: array([1, 1, -1, 0], dtype=int32)</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="to_numpy"><a class="viewcode-back" href="../../../container/container_methods/to_numpy.html#ivy.container.container_methods.to_numpy">[docs]</a><span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_numpy. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_numpy also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of numpy arrays copying all the element of the container</span>
<span class="sd">        ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` instances:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.native_array([[-1, 0, 1], [-1, 0, 1], [1, 0, -1]]),\</span>
<span class="sd">                b=ivy.native_array([[-1, 0, 0], [1, 0, 1], [1, 1, 1]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.to_numpy()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([[-1, 0, 1],</span>
<span class="sd">                  [-1, 0, 1],</span>
<span class="sd">                  [1, 0, -1]], dtype=int32),</span>
<span class="sd">        b: array([[-1, 0, 0],</span>
<span class="sd">                  [1, 0, 1],</span>
<span class="sd">                  [1, 1, 1]], dtype=int32)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.native_array([[-1, 0, 1], [-1, 0, 1], [1, 0, -1]]),\</span>
<span class="sd">                        b=ivy.native_array([[-1, 0, 0], [1, 0, 1], [1, 1, 1]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_to_numpy(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([[-1, 0, 1],</span>
<span class="sd">                  [-1, 0, 1],</span>
<span class="sd">                  [1, 0, -1]], dtype=int32),</span>
<span class="sd">        b: array([[-1, 0, 0],</span>
<span class="sd">                  [1, 0, 1],</span>
<span class="sd">                  [1, 1, 1]], dtype=int32)</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_to_list"><a class="viewcode-back" href="../../../container/container_methods/static_to_list.html#ivy.container.container_methods.static_to_list">[docs]</a><span class="k">def</span> <span class="nf">static_to_list</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.to_list. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_list also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list representation of the input array ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="to_list"><a class="viewcode-back" href="../../../container/container_methods/to_list.html#ivy.container.container_methods.to_list">[docs]</a><span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.to_list. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.to_list also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A list representation of the input array ``x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_stable_divide"><a class="viewcode-back" href="../../../container/container_methods/static_stable_divide.html#ivy.container.container_methods.static_stable_divide">[docs]</a><span class="k">def</span> <span class="nf">static_stable_divide</span><span class="p">(</span>
    <span class="n">numerator</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">min_denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stable_divide. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stable_divide also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numerator</span>
<span class="sd">        Container of the numerators of the division.</span>
<span class="sd">    denominator</span>
<span class="sd">        Container of the denominators of the division.</span>
<span class="sd">    min_denominator</span>
<span class="sd">        Container of the minimum denominator to use,</span>
<span class="sd">        use global ivy._MIN_DENOMINATOR by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of elements containing the new items following the numerically</span>
<span class="sd">        stable division.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([10., 15.]), b=ivy.asarray([20., 25.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.stable_divide(x, 0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([20., 30.]),</span>
<span class="sd">        b: ivy.array([40., 50.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=1, b=10)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.asarray([4, 5])</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.25, 0.2]),</span>
<span class="sd">        b: ivy.array([2.5, 2.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=1, b=10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.array((4.5, 9))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: array([0.22222222, 0.11111111]),</span>
<span class="sd">        b: array([2.22222222, 1.11111111])</span>
<span class="sd">    }</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([1., 2.]), b=ivy.asarray([3., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.asarray([0.5, 2.5]), b=ivy.asarray([3.5, 0.4]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0.8]),</span>
<span class="sd">        b: ivy.array([0.857, 10.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([1., 2.], [3., 4.]),\</span>
<span class="sd">                          b=ivy.asarray([5., 6.], [7., 8.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.asarray([0.5, 2.5]), b=ivy.asarray([3.5, 0.4]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.stable_divide(x, y, min_denominator=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.4, 0.444]),</span>
<span class="sd">        b: ivy.array([0.909, 2.5])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="stable_divide"><a class="viewcode-back" href="../../../container/container_methods/stable_divide.html#ivy.container.container_methods.stable_divide">[docs]</a><span class="k">def</span> <span class="nf">stable_divide</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">min_denominator</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stable_divide. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stable_divide</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    denominator</span>
<span class="sd">        Container of the denominators of the division.</span>
<span class="sd">    min_denominator</span>
<span class="sd">        Container of the minimum denominator to use,</span>
<span class="sd">        use global ivy._MIN_DENOMINATOR by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container of numpy arrays copying all the element of the container</span>
<span class="sd">        ``self``.</span>
<span class="sd">        A container of elements containing the new items following the numerically</span>
<span class="sd">        stable division, using ``self`` as the numerator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([3., 6.]), b=ivy.asarray([9., 12.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.stable_divide(5)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.6, 1.2]),</span>
<span class="sd">        b: ivy.array([1.8, 2.4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([[2., 4.], [6., 8.]]),\</span>
<span class="sd">                          b=ivy.asarray([[10., 12.], [14., 16.]]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.stable_divide(2, min_denominator=2)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0.5, 1.],</span>
<span class="sd">              [1.5, 2.]]),</span>
<span class="sd">        b: ivy.array([[2.5, 3.],</span>
<span class="sd">              [3.5, 4.]])</span>
<span class="sd">    }</span>


<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.asarray([3., 6.]), b=ivy.asarray([9., 12.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.asarray([6., 9.]), b=ivy.asarray([12., 15.]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.stable_divide(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 0.667]),</span>
<span class="sd">        b: ivy.array([0.75, 0.8])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_stable_pow"><a class="viewcode-back" href="../../../container/container_methods/static_stable_pow.html#ivy.container.container_methods.static_stable_pow">[docs]</a><span class="k">def</span> <span class="nf">static_stable_pow</span><span class="p">(</span>
    <span class="n">base</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stable_pow. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stable_pow also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base</span>
<span class="sd">        Container of the base.</span>
<span class="sd">    exponent</span>
<span class="sd">        Container of the exponent.</span>
<span class="sd">    min_base</span>
<span class="sd">        The minimum base to use, use global ivy._MIN_BASE by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of elements containing the new items following the numerically</span>
<span class="sd">        stable power.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="stable_pow"><a class="viewcode-back" href="../../../container/container_methods/stable_pow.html#ivy.container.container_methods.stable_pow">[docs]</a><span class="k">def</span> <span class="nf">stable_pow</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stable_pow. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stable_pow</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container of the base.</span>
<span class="sd">    exponent</span>
<span class="sd">        Container of the exponent.</span>
<span class="sd">    min_base</span>
<span class="sd">        The minimum base to use, use global ivy._MIN_BASE by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of elements containing the new items following the numerically</span>
<span class="sd">        stable power.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_floormod"><a class="viewcode-back" href="../../../container/container_methods/static_floormod.html#ivy.container.container_methods.static_floormod">[docs]</a><span class="k">def</span> <span class="nf">static_floormod</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.floormod. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.floormod also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container to floordmod.</span>
<span class="sd">    y</span>
<span class="sd">        denominator input for floormod.</span>
<span class="sd">    min_denominator</span>
<span class="sd">        Container of the minimum denominator to use,</span>
<span class="sd">        use global ivy._MIN_DENOMINATOR by default.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of the same shape and type as x, with the elements at its</span>
<span class="sd">        leaves floor modded.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="floormod"><a class="viewcode-back" href="../../../container/container_methods/floormod.html#ivy.container.container_methods.floormod">[docs]</a><span class="k">def</span> <span class="nf">floormod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.floormod. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.floormod</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container to floordmod.</span>
<span class="sd">    y</span>
<span class="sd">        denominator input for floormod.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container of the same shape and type as self, with the elements at its</span>
<span class="sd">        leaves floor modded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_einops_rearrange"><a class="viewcode-back" href="../../../container/container_methods/static_einops_rearrange.html#ivy.container.container_methods.static_einops_rearrange">[docs]</a><span class="k">def</span> <span class="nf">static_einops_rearrange</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.einops_rearrange. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.einops_rearrange</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    **axes_lengths</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.rearrange applied.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einops_rearrange"><a class="viewcode-back" href="../../../container/container_methods/einops_rearrange.html#ivy.container.container_methods.einops_rearrange">[docs]</a><span class="k">def</span> <span class="nf">einops_rearrange</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.einops_rearrange. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.einops_rearrange</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern</span>
<span class="sd">        Rearrangement pattern.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    axes_lengths</span>
<span class="sd">        Any additional specifications for dimensions.</span>
<span class="sd">    **axes_lengths</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        ivy.Container with each array having einops.rearrange applied.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_indices_where"><a class="viewcode-back" href="../../../container/container_methods/static_indices_where.html#ivy.container.container_methods.static_indices_where">[docs]</a><span class="k">def</span> <span class="nf">static_indices_where</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.indices_where. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.indices_where</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Boolean array, for which indices are desired.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Indices for where the boolean array is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="indices_where"><a class="viewcode-back" href="../../../container/container_methods/indices_where.html#ivy.container.container_methods.indices_where">[docs]</a><span class="k">def</span> <span class="nf">indices_where</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.indices_where. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.indices_where</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Boolean array, for which indices are desired.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Indices for where the boolean array is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_one_hot"><a class="viewcode-back" href="../../../container/container_methods/static_one_hot.html#ivy.container.container_methods.static_one_hot">[docs]</a><span class="k">def</span> <span class="nf">static_one_hot</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.one_hot. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.one_hot</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices</span>
<span class="sd">        Indices for where the ones should be scattered *[batch_shape, dim]*</span>
<span class="sd">    depth</span>
<span class="sd">        Scalar defining the depth of the one-hot dimension.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container with tensors of zeros with the same shape and type as the inputs,</span>
<span class="sd">        unless dtype provided which overrides.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="one_hot"><a class="viewcode-back" href="../../../container/container_methods/one_hot.html#ivy.container.container_methods.one_hot">[docs]</a><span class="k">def</span> <span class="nf">one_hot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.one_hot. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.one_hot</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Indices for where the ones should be scattered *[batch_shape, dim]*</span>
<span class="sd">    depth</span>
<span class="sd">        Scalar defining the depth of the one-hot dimension.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        container with tensors of zeros with the same shape and type as the inputs,</span>
<span class="sd">        unless dtype provided which overrides.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_clip_matrix_norm"><a class="viewcode-back" href="../../../container/container_methods/static_clip_matrix_norm.html#ivy.container.container_methods.static_clip_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">static_clip_matrix_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.clip_matrix_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_matrix_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array containing elements to clip.</span>
<span class="sd">    max_norm</span>
<span class="sd">        The maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        The p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the matrix norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1., 2.]]), \</span>
<span class="sd">                          b=ivy.array([[3., 4., 5.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_clip_matrix_norm(x, 2.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 0.894, 1.79]]),</span>
<span class="sd">        b: ivy.array([[0.849, 1.13, 1.41]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="clip_matrix_norm"><a class="viewcode-back" href="../../../container/container_methods/clip_matrix_norm.html#ivy.container.container_methods.clip_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">clip_matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip_matrix_norm. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.clip_matrix_norm</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array containing elements to clip.</span>
<span class="sd">    max_norm</span>
<span class="sd">        The maximum value of the array norm.</span>
<span class="sd">    p</span>
<span class="sd">        The p-value for computing the p-norm. Default is 2.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        An array with the matrix norm downscaled to the max norm if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` instance method:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1., 2.]]), \</span>
<span class="sd">                          b=ivy.array([[3., 4., 5.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip_matrix_norm(2.0, 1.0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 1., 2.]]),</span>
<span class="sd">        b: ivy.array([[1.2, 1.6, 2.]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.gradients</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_variable"><a class="viewcode-back" href="../../../container/container_methods/static_variable.html#ivy.container.container_methods.static_variable">[docs]</a><span class="k">def</span> <span class="nf">static_variable</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.variable. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.variable also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        An ivy container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with ivy variables, that supports gradient computation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1., 2.]), b=ivy.array([3., 4.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_variable(x)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4.])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="variable"><a class="viewcode-back" href="../../../container/container_methods/variable.html#ivy.container.container_methods.variable">[docs]</a><span class="k">def</span> <span class="nf">variable</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.variable. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.variable also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        An ivy container.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with ivy variables, that supports gradient computation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.3, 1.]), b=ivy.array([-1., 2.2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.variable()</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.3, 1.]),</span>
<span class="sd">        b: ivy.array([-1., 2.2])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_is_variable"><a class="viewcode-back" href="../../../container/container_methods/static_is_variable.html#ivy.container.container_methods.static_is_variable">[docs]</a><span class="k">def</span> <span class="nf">static_is_variable</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.is_variable. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.is_variable also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        An ivy container.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively a variable, rather than an</span>
<span class="sd">        array. For frameworks like JAX that do not have exclusive variable types,</span>
<span class="sd">        the function will always return False if this flag is set, otherwise the</span>
<span class="sd">        check is the same for general arrays. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, true if x is a trainable variable, false otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array(3.2), b=ivy.array(2))</span>
<span class="sd">    &gt;&gt;&gt; is_var = ivy.Container.static_is_variable(x, exclusive=True)</span>
<span class="sd">    &gt;&gt;&gt; print(is_var)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.variable(ivy.array([2.0, -1.0, 0.0])),\</span>
<span class="sd">                          b=ivy.array([0., -0.4, 8]))</span>
<span class="sd">    &gt;&gt;&gt; exclusive = ivy.Container(a=False, b=True)</span>
<span class="sd">    &gt;&gt;&gt; is_var = ivy.Container.static_is_variable(x, exclusive=exclusive)</span>
<span class="sd">    &gt;&gt;&gt; print(is_var)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="is_variable"><a class="viewcode-back" href="../../../container/container_methods/is_variable.html#ivy.container.container_methods.is_variable">[docs]</a><span class="k">def</span> <span class="nf">is_variable</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.is_variable. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.is_variable also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        An ivy container.</span>
<span class="sd">    exclusive</span>
<span class="sd">        Whether to check if the data type is exclusively a variable, rather than an</span>
<span class="sd">        array. For frameworks like JAX that do not have exclusive variable types,</span>
<span class="sd">        the function will always return False if this flag is set, otherwise the</span>
<span class="sd">        check is the same for general arrays. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Boolean, true if x is a trainable variable, false otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a = ivy.array(3.2), b=ivy.array(2))</span>
<span class="sd">    &gt;&gt;&gt; is_var = x.is_variable(exclusive=True)</span>
<span class="sd">    &gt;&gt;&gt; print(is_var)</span>
<span class="sd">    {</span>
<span class="sd">        a: false,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.variable(ivy.array([2.0, -1.0, 0.0])),\</span>
<span class="sd">                          b=ivy.array([0., -0.4, 8]))</span>
<span class="sd">    &gt;&gt;&gt; exclusive = ivy.Container(a=False, b=True)</span>
<span class="sd">    &gt;&gt;&gt; is_var = x.is_variable(exclusive=exclusive)</span>
<span class="sd">    &gt;&gt;&gt; print(is_var)</span>
<span class="sd">    {</span>
<span class="sd">        a: true,</span>
<span class="sd">        b: false</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_variable_data"><a class="viewcode-back" href="../../../container/container_methods/static_variable_data.html#ivy.container.container_methods.static_variable_data">[docs]</a><span class="k">def</span> <span class="nf">static_variable_data</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.variable_data. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.variable_data also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        An ivy variable or container of variables.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The internal data stored by the variable.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="variable_data"><a class="viewcode-back" href="../../../container/container_methods/variable_data.html#ivy.container.container_methods.variable_data">[docs]</a><span class="k">def</span> <span class="nf">variable_data</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.variable_data. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.variable_data also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        An ivy container of variables.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The internal data stored by the variable.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_stop_gradient"><a class="viewcode-back" href="../../../container/container_methods/static_stop_gradient.html#ivy.container.container_methods.static_stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">static_stop_gradient</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">preserve_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stop_gradient. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stop_gradient also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Array or Container for which to stop the gradient.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    preserve_type</span>
<span class="sd">        Whether to preserve the input type (ivy.Variable or ivy.Array),</span>
<span class="sd">        otherwise an array is always returned. Default is True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The same array x, but with no gradient information.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_stop_gradient(x, preserve_type=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_stop_gradient(x, preserve_type=True, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="stop_gradient"><a class="viewcode-back" href="../../../container/container_methods/stop_gradient.html#ivy.container.container_methods.stop_gradient">[docs]</a><span class="k">def</span> <span class="nf">stop_gradient</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">preserve_type</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stop_gradient. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.stop_gradient also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Container for which to stop the gradient.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    preserve_type</span>
<span class="sd">        Whether to preserve the input type (ivy.Variable or ivy.Array),</span>
<span class="sd">        otherwise an array is always returned. Default is True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The same array x, but with no gradient information.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.stop_gradient(preserve_type=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; x.stop_gradient(preserve_type=True, out=x)</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="adam_step"><a class="viewcode-back" href="../../../container/container_methods/adam_step.html#ivy.container.container_methods.adam_step">[docs]</a><span class="k">def</span> <span class="nf">adam_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">mw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">vw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.adam_step. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.adam_step also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    mw</span>
<span class="sd">        running average of the gradients.</span>
<span class="sd">    vw</span>
<span class="sd">        running average of second moments of the gradients.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The adam step delta.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                             b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; mw = ivy.array([1., 4., 9.])</span>
<span class="sd">    &gt;&gt;&gt; vw = ivy.array([0.,])</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([3.4])</span>
<span class="sd">    &gt;&gt;&gt; beta1 = 0.87</span>
<span class="sd">    &gt;&gt;&gt; beta2 = 0.976</span>
<span class="sd">    &gt;&gt;&gt; epsilon = 1e-5</span>
<span class="sd">    &gt;&gt;&gt; adam_step_delta = dcdw.adam_step(mw, vw, step, beta1=beta1, beta2=beta2,\</span>
<span class="sd">                                         epsilon=epsilon)</span>
<span class="sd">    &gt;&gt;&gt; print(adam_step_delta)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([6.49e+04, 1.74e+01, 1.95e+01]),</span>
<span class="sd">        b: ivy.array([2.02, 4.82, 8.17])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0.87, 3.61, 8.09]),</span>
<span class="sd">        b: ivy.array([1.26, 4., 8.48])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.024, 0.096]),</span>
<span class="sd">        b: ivy.array([0.216, 0.384, 0.6])</span>
<span class="sd">    })</span>
<span class="sd">    </span>
<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                            b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; mw = ivy.Container(a=ivy.array([0., 0., 0.]),\</span>
<span class="sd">                        b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; vw = ivy.Container(a=ivy.array([0.,]),\</span>
<span class="sd">                        b=ivy.array([0.,]))</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([3.4])</span>
<span class="sd">    &gt;&gt;&gt; beta1 = 0.87</span>
<span class="sd">    &gt;&gt;&gt; beta2 = 0.976</span>
<span class="sd">    &gt;&gt;&gt; epsilon = 1e-5</span>
<span class="sd">    &gt;&gt;&gt; adam_step_delta = dcdw.adam_step(mw, vw, step, beta1=beta1, beta2=beta2,\</span>
<span class="sd">                                         epsilon=epsilon)</span>
<span class="sd">    &gt;&gt;&gt; print(adam_step_delta)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([0., 0.626, 0.626]),</span>
<span class="sd">        b: ivy.array([0.626, 0.626, 0.626])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.13, 0.26]),</span>
<span class="sd">        b: ivy.array([0.39, 0.52, 0.65])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0., 0.024, 0.096]),</span>
<span class="sd">        b: ivy.array([0.216, 0.384, 0.6])</span>
<span class="sd">    })</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="optimizer_update"><a class="viewcode-back" href="../../../container/container_methods/optimizer_update.html#ivy.container.container_methods.optimizer_update">[docs]</a><span class="k">def</span> <span class="nf">optimizer_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">effective_grad</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the true or effective derivatives</span>
<span class="sd">    of some cost c with respect to ws, [dc/dw for w in ws].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    effective_grad</span>
<span class="sd">        Effective gradients of the cost c with respect to the weights ws,</span>
<span class="sd">        [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the optimizer updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                        b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; lr = 3e-4</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(ws_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.Container(a=ivy.array([0., 0., 0.]),\</span>
<span class="sd">                                       b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; lr = 3e-4</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr, out=w)</span>
<span class="sd">    &gt;&gt;&gt; print(w)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([0., 1., 2.]),\</span>
<span class="sd">                        b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; effective_grad = ivy.Container(a=ivy.array([0., 0., 0.]),\</span>
<span class="sd">                                    b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array([3e-4])</span>
<span class="sd">    &gt;&gt;&gt; ws_new = w.optimizer_update(effective_grad, lr, stop_gradients=False)</span>
<span class="sd">    &gt;&gt;&gt; print(ws_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="gradient_descent_update"><a class="viewcode-back" href="../../../container/container_methods/gradient_descent_update.html#ivy.container.container_methods.gradient_descent_update">[docs]</a><span class="k">def</span> <span class="nf">gradient_descent_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.gradient_descent_update.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.gradient_descent_update also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be</span>
<span class="sd">        updated relative to the gradient.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new weights, following the gradient descent updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">                          b=ivy.array([3.48, 5.72, 1.98]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([0.5, 0.2, 0.1])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.3)</span>
<span class="sd">    &gt;&gt;&gt; w_new = w.gradient_descent_update(dcdw, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(w_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.85, 1.94, 2.97]),</span>
<span class="sd">        b: ivy.array([3.33, 5.66, 1.95])</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1., 2., 3.]),\</span>
<span class="sd">                          b=ivy.array([3.48, 5.72, 1.98]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0.5, 0.2, 0.1]),\</span>
<span class="sd">                             b=ivy.array([2., 3.42, 1.69]))</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.3)</span>
<span class="sd">    &gt;&gt;&gt; w_new = w.gradient_descent_update(dcdw, lr)</span>
<span class="sd">    &gt;&gt;&gt; print(w_new)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.85, 1.94, 2.97]),</span>
<span class="sd">        b: ivy.array([2.88, 4.69, 1.47])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="lars_update"><a class="viewcode-back" href="../../../container/container_methods/lars_update.html#ivy.container.container_methods.lars_update">[docs]</a><span class="k">def</span> <span class="nf">lars_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the derivatives of some cost c with</span>
<span class="sd">    respect to ws, [dc/dw for w in ws], by applying Layerwise Adaptive Rate Scaling</span>
<span class="sd">    (LARS) method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate, the rate at which the weights should be updated relative to</span>
<span class="sd">        the gradient.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LARS updates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="adam_update"><a class="viewcode-back" href="../../../container/container_methods/adam_update.html#ivy.container.container_methods.adam_update">[docs]</a><span class="k">def</span> <span class="nf">adam_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the derivatives of some cost c with</span>
<span class="sd">    respect to ws, using ADAM update. `[reference]</span>

<span class="sd">    &lt;https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, and also new mw and vw, following the adam</span>
<span class="sd">        updates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="lamb_update"><a class="viewcode-back" href="../../../container/container_methods/lamb_update.html#ivy.container.container_methods.lamb_update">[docs]</a><span class="k">def</span> <span class="nf">lamb_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">dcdw</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">lr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">mw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">vw_tm1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">beta1</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
    <span class="n">beta2</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.999</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">max_trust_ratio</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">decay_lambda</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stop_gradients</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Update weights ws of some function, given the derivatives of some cost c with</span>
<span class="sd">    respect to ws, [dc/dw for w in ws], by applying LAMB method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Weights of the function to be updated.</span>
<span class="sd">    dcdw</span>
<span class="sd">        Derivates of the cost c with respect to the weights ws, [dc/dw for w in ws].</span>
<span class="sd">    lr</span>
<span class="sd">        Learning rate(s), the rate(s) at which the weights should be updated</span>
<span class="sd">        relative to the gradient.</span>
<span class="sd">    mw_tm1</span>
<span class="sd">        running average of the gradients, from the previous time-step.</span>
<span class="sd">    vw_tm1</span>
<span class="sd">        running average of second moments of the gradients, from the previous</span>
<span class="sd">        time-step.</span>
<span class="sd">    step</span>
<span class="sd">        training step.</span>
<span class="sd">    beta1</span>
<span class="sd">        gradient forgetting factor (Default value = 0.9).</span>
<span class="sd">    beta2</span>
<span class="sd">        second moment of gradient forgetting factor (Default value = 0.999).</span>
<span class="sd">    epsilon</span>
<span class="sd">        divisor during adam update, preventing division by zero</span>
<span class="sd">        (Default value = 1e-7).</span>
<span class="sd">    max_trust_ratio</span>
<span class="sd">        The maximum value for the trust ratio. Default is 10.</span>
<span class="sd">    decay_lambda</span>
<span class="sd">        The factor used for weight decay. Default is zero.</span>
<span class="sd">    stop_gradients</span>
<span class="sd">        Whether to stop the gradients of the variables after each gradient step.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The new function weights ws_new, following the LAMB updates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1., 2., 3.]), b=ivy.array([4., 5., 6.]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.array([3., 4., 5.])</span>
<span class="sd">    &gt;&gt;&gt; mw_tm1 = ivy.array([0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; vw_tm1 = ivy.array([0.])</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(1.)</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([2])</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.lamb_update(dcdw, mw_tm1, vw_tm1, lr, step)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([1., 2., 3.]),</span>
<span class="sd">        b: ivy.array([4., 5., 6.])</span>
<span class="sd">    }, ivy.array([0.3, 0.4, 0.5]), ivy.array([1.01, 1.01, 1.02]))</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; w = ivy.Container(a=ivy.array([1.,3.,5.]),\</span>
<span class="sd">                          b=ivy.array([3.,4.,2.]))</span>
<span class="sd">    &gt;&gt;&gt; dcdw = ivy.Container(a=ivy.array([0.2,0.3,0.6]),\</span>
<span class="sd">                             b=ivy.array([0.6,0.4,0.7]))</span>
<span class="sd">    &gt;&gt;&gt; mw_tm1 = ivy.Container(a=ivy.array([0.,0.,0.]),\</span>
<span class="sd">                               b=ivy.array([0.,0.,0.]))</span>

<span class="sd">    &gt;&gt;&gt; vw_tm1 = ivy.Container(a=ivy.array([0.,]),\</span>
<span class="sd">                               b=ivy.array([0.,]))</span>
<span class="sd">    &gt;&gt;&gt; step = ivy.array([3.4])</span>
<span class="sd">    &gt;&gt;&gt; beta1 = 0.9</span>
<span class="sd">    &gt;&gt;&gt; beta2 = 0.999</span>
<span class="sd">    &gt;&gt;&gt; epsilon = 1e-7</span>
<span class="sd">    &gt;&gt;&gt; max_trust_ratio = 10</span>
<span class="sd">    &gt;&gt;&gt; decay_lambda = 0</span>
<span class="sd">    &gt;&gt;&gt; stop_gradients = True</span>
<span class="sd">    &gt;&gt;&gt; lr = ivy.array(0.5)</span>
<span class="sd">    &gt;&gt;&gt; new_weights = w.lamb_update(dcdw, lr, mw_tm1, vw_tm1, step, beta1=beta1,\</span>
<span class="sd">                                    beta2=beta2, epsilon=epsilon,\</span>
<span class="sd">                                    max_trust_ratio=max_trust_ratio,\</span>
<span class="sd">                                    decay_lambda=decay_lambda,\</span>
<span class="sd">                                    stop_gradients=stop_gradients)</span>
<span class="sd">    &gt;&gt;&gt; print(new_weights)</span>
<span class="sd">    ({</span>
<span class="sd">        a: ivy.array([-0.708, 1.29, 3.29]),</span>
<span class="sd">        b: ivy.array([1.45, 2.45, 0.445])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([0.02, 0.03, 0.06]),</span>
<span class="sd">        b: ivy.array([0.06, 0.04, 0.07])</span>
<span class="sd">    }, {</span>
<span class="sd">        a: ivy.array([4.0e-05, 9.0e-05, 3.6e-04]),</span>
<span class="sd">        b: ivy.array([0.00036, 0.00016, 0.00049])</span>
<span class="sd">    })</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.layers</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_linear"><a class="viewcode-back" href="../../../container/container_methods/static_linear.html#ivy.container.container_methods.static_linear">[docs]</a><span class="k">def</span> <span class="nf">static_linear</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="linear"><a class="viewcode-back" href="../../../container/container_methods/linear.html#ivy.container.container_methods.linear">[docs]</a><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_dropout"><a class="viewcode-back" href="../../../container/container_methods/static_dropout.html#ivy.container.container_methods.static_dropout">[docs]</a><span class="k">def</span> <span class="nf">static_dropout</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="dropout"><a class="viewcode-back" href="../../../container/container_methods/dropout.html#ivy.container.container_methods.dropout">[docs]</a><span class="k">def</span> <span class="nf">dropout</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">prob</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_scaled_dot_product_attention"><a class="viewcode-back" href="../../../container/container_methods/static_scaled_dot_product_attention.html#ivy.container.container_methods.static_scaled_dot_product_attention">[docs]</a><span class="k">def</span> <span class="nf">static_scaled_dot_product_attention</span><span class="p">(</span>
    <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;scaled_dot_product_attention&quot;</span><span class="p">,</span>
        <span class="n">q</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="scaled_dot_product_attention"><a class="viewcode-back" href="../../../container/container_methods/scaled_dot_product_attention.html#ivy.container.container_methods.scaled_dot_product_attention">[docs]</a><span class="k">def</span> <span class="nf">scaled_dot_product_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_scaled_dot_product_attention</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">static_multi_head_attention</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">scale</span><span class="p">,</span>
    <span class="n">num_heads</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;multi_head_attention&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">num_heads</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">to_q_fn</span><span class="o">=</span><span class="n">to_q_fn</span><span class="p">,</span>
        <span class="n">to_kv_fn</span><span class="o">=</span><span class="n">to_kv_fn</span><span class="p">,</span>
        <span class="n">to_out_fn</span><span class="o">=</span><span class="n">to_out_fn</span><span class="p">,</span>
        <span class="n">to_q_v</span><span class="o">=</span><span class="n">to_q_v</span><span class="p">,</span>
        <span class="n">to_kv_v</span><span class="o">=</span><span class="n">to_kv_v</span><span class="p">,</span>
        <span class="n">to_out_v</span><span class="o">=</span><span class="n">to_out_v</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="multi_head_attention"><a class="viewcode-back" href="../../../container/container_methods/multi_head_attention.html#ivy.container.container_methods.multi_head_attention">[docs]</a><span class="k">def</span> <span class="nf">multi_head_attention</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">,</span>
    <span class="n">num_heads</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">context</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_fn</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_q_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_kv_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">to_out_v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_multi_head_attention</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">num_heads</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">to_q_fn</span><span class="o">=</span><span class="n">to_q_fn</span><span class="p">,</span>
        <span class="n">to_kv_fn</span><span class="o">=</span><span class="n">to_kv_fn</span><span class="p">,</span>
        <span class="n">to_out_fn</span><span class="o">=</span><span class="n">to_out_fn</span><span class="p">,</span>
        <span class="n">to_q_v</span><span class="o">=</span><span class="n">to_q_v</span><span class="p">,</span>
        <span class="n">to_kv_v</span><span class="o">=</span><span class="n">to_kv_v</span><span class="p">,</span>
        <span class="n">to_out_v</span><span class="o">=</span><span class="n">to_out_v</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">static_conv1d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.conv1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,w, d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fw,d_in, d_out]*. (d_in must be the same as d from x)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[2., 3., 4.], [5., 6., 7.]]]), \</span>
<span class="sd">                          b =ivy.array([[[7., 8., 9.], [10., 11., 12]]]))</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[0., 0.5, 1.], [0.25, 0.5, 0.75], [-0.5, 0., 0.5 ]]])</span>
<span class="sd">    &gt;&gt;&gt; result= ivy.Container.static_conv1d(x,filters,(1,),&#39;VALID&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[-1.25, 2.5, 6.25], \</span>
<span class="sd">                       [-2., 5.5, 13.]]]), \</span>
<span class="sd">        b: ivy.array([[[-2.5, 7.5, 17.5], \</span>
<span class="sd">                       [-3.25, 10.5, 24.2]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="conv1d"><a class="viewcode-back" href="../../../container/container_methods/conv1d.html#ivy.container.container_methods.conv1d">[docs]</a><span class="k">def</span> <span class="nf">conv1d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.conv1d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.conv1d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,w, d_in]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fw,d_in, d_out]*. (d_in must be the same as d from x)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NWC&quot; or &quot;NCW&quot;. Defaults to &quot;NWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[2., 3., 4.], [5., 6., 7.]]]), \</span>
<span class="sd">                          b =ivy.array([[[7., 8., 9.], [10., 11., 12]]]))</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.array([[[0., 0.5, 1.], [0.25, 0.5, 0.75], [-0.5, 0., 0.5 ]]])</span>
<span class="sd">    &gt;&gt;&gt; result= x.conv1d(filters, (1,), &#39;VALID&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[-1.25, 2.5, 6.25], \</span>
<span class="sd">                       [-2., 5.5, 13.]]]), \</span>
<span class="sd">        b: ivy.array([[[-2.5, 7.5, 17.5], \</span>
<span class="sd">                       [-3.25, 10.5, 24.2]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_conv2d"><a class="viewcode-back" href="../../../container/container_methods/static_conv2d.html#ivy.container.container_methods.static_conv2d">[docs]</a><span class="k">def</span> <span class="nf">static_conv2d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv2d"><a class="viewcode-back" href="../../../container/container_methods/conv2d.html#ivy.container.container_methods.conv2d">[docs]</a><span class="k">def</span> <span class="nf">conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_conv1d_transpose"><a class="viewcode-back" href="../../../container/container_methods/static_conv1d_transpose.html#ivy.container.container_methods.static_conv1d_transpose">[docs]</a><span class="k">def</span> <span class="nf">static_conv1d_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv1d_transpose&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="conv1d_transpose"><a class="viewcode-back" href="../../../container/container_methods/conv1d_transpose.html#ivy.container.container_methods.conv1d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv1d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv1d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">static_conv2d_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;conv2d_transpose&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="conv2d_transpose"><a class="viewcode-back" href="../../../container/container_methods/conv2d_transpose.html#ivy.container.container_methods.conv2d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv2d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_conv2d_transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filters</span><span class="p">,</span>
        <span class="n">strides</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">,</span>
        <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
        <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">,</span>
        <span class="n">dilations</span><span class="o">=</span><span class="n">dilations</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">static_depthwise_conv2d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.depthwise_conv2d. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.depthwise_conv2d also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input image *[batch_size,h,w,d]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in]*. (d_in must be the same as d from x)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; inp = ivy.Container(a=a, b=b)</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_depthwise_conv2d( \</span>
<span class="sd">                                                inp, \</span>
<span class="sd">                                                filters, \</span>
<span class="sd">                                                strides=2, \</span>
<span class="sd">                                                padding=&#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    [1, 64, 64, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="depthwise_conv2d"><a class="viewcode-back" href="../../../container/container_methods/depthwise_conv2d.html#ivy.container.container_methods.depthwise_conv2d">[docs]</a><span class="k">def</span> <span class="nf">depthwise_conv2d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.depthwise_conv2d. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.depthwise_conv2d</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input image *[batch_size,h,w,d]*.</span>
<span class="sd">    filters</span>
<span class="sd">        Convolution filters *[fh,fw,d_in]*. (d_in must be the same as d from self)</span>
<span class="sd">    strides</span>
<span class="sd">        The stride of the sliding window for each dimension of input.</span>
<span class="sd">    padding</span>
<span class="sd">        &quot;SAME&quot; or &quot;VALID&quot; indicating the algorithm, or list indicating the</span>
<span class="sd">        per-dimension paddings.</span>
<span class="sd">    data_format</span>
<span class="sd">        &quot;NHWC&quot; or &quot;NCHW&quot;. Defaults to &quot;NHWC&quot;.</span>
<span class="sd">    dilations</span>
<span class="sd">        The dilation factor for each dimension of input. (Default value = 1)</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The result of the convolution operation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; b = ivy.randint(0, 255, shape=(1, 128, 128, 3)).astype(ivy.float32) / 255.0</span>
<span class="sd">    &gt;&gt;&gt; inp = ivy.Container(a=a, b=b)</span>
<span class="sd">    &gt;&gt;&gt; filters = ivy.random_normal(mean=0, std=1, shape=[3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = inp.depthwise_conv2d(filters, 2, &#39;SAME&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y.shape)</span>
<span class="sd">    [1, 64, 64, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_conv3d"><a class="viewcode-back" href="../../../container/container_methods/static_conv3d.html#ivy.container.container_methods.static_conv3d">[docs]</a><span class="k">def</span> <span class="nf">static_conv3d</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv3d"><a class="viewcode-back" href="../../../container/container_methods/conv3d.html#ivy.container.container_methods.conv3d">[docs]</a><span class="k">def</span> <span class="nf">conv3d</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_conv3d_transpose"><a class="viewcode-back" href="../../../container/container_methods/static_conv3d_transpose.html#ivy.container.container_methods.static_conv3d_transpose">[docs]</a><span class="k">def</span> <span class="nf">static_conv3d_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="conv3d_transpose"><a class="viewcode-back" href="../../../container/container_methods/conv3d_transpose.html#ivy.container.container_methods.conv3d_transpose">[docs]</a><span class="k">def</span> <span class="nf">conv3d_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">filters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">padding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NDHWC&quot;</span><span class="p">,</span>
    <span class="n">dilations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_lstm_update"><a class="viewcode-back" href="../../../container/container_methods/static_lstm_update.html#ivy.container.container_methods.static_lstm_update">[docs]</a><span class="k">def</span> <span class="nf">static_lstm_update</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">init_h</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">init_c</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">recurrent_kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">recurrent_bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;lstm_update&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">init_h</span><span class="p">,</span>
        <span class="n">init_c</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">recurrent_kernel</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">recurrent_bias</span><span class="o">=</span><span class="n">recurrent_bias</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="lstm_update"><a class="viewcode-back" href="../../../container/container_methods/lstm_update.html#ivy.container.container_methods.lstm_update">[docs]</a><span class="k">def</span> <span class="nf">lstm_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">init_h</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">init_c</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">recurrent_kernel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">recurrent_bias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_lstm_update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_h</span><span class="p">,</span>
        <span class="n">init_c</span><span class="p">,</span>
        <span class="n">kernel</span><span class="p">,</span>
        <span class="n">recurrent_kernel</span><span class="p">,</span>
        <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
        <span class="n">recurrent_bias</span><span class="o">=</span><span class="n">recurrent_bias</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="c1">#ivy.container.linear_algebra</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="n">inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>


<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor,PyMethodParameters</span>
<div class="viewcode-block" id="matmul"><a class="viewcode-back" href="../../../container/container_methods/matmul.html#ivy.container.container_methods.matmul">[docs]</a><span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_nests</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    With :code:`ivy.Container` instance inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5., 2.]), b=ivy.array([2., 1.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([7., 2.]), b=ivy.array([3., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.matmul(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(39.),</span>
<span class="sd">        b: ivy.array(8.)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_cholesky"><a class="viewcode-back" href="../../../container/container_methods/static_cholesky.html#ivy.container.container_methods.static_cholesky">[docs]</a><span class="k">def</span> <span class="nf">static_cholesky</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">upper</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cholesky. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.cholesky also applies to this</span>
<span class="sd">    method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container having shape (..., M, M) and whose innermost two</span>
<span class="sd">        dimensions form square symmetric positive-definite matrices. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    upper</span>
<span class="sd">        If True, the result must be the upper-triangular Cholesky factor U. If</span>
<span class="sd">        False, the result must be the lower-triangular Cholesky factor L.</span>
<span class="sd">        Default: False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Cholesky factors for each square matrix. If upper</span>
<span class="sd">        is False, the returned container must contain lower-triangular matrices;</span>
<span class="sd">        otherwise, the returned container must contain upper-triangular matrices.</span>
<span class="sd">        The returned container must have a floating-point data type determined by</span>
<span class="sd">        Type Promotion Rules and must have the same shape as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[3., -1.], [-1., 3.]]), \</span>
<span class="sd">                          b=ivy.array([[2., 1.], [1., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_cholesky(x, upper=&#39;false&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1.73, -0.577],</span>
<span class="sd">                        [0., 1.63]]),</span>
<span class="sd">        b: ivy.array([[1.41, 0.707],</span>
<span class="sd">                        [0., 0.707]])</span>
<span class="sd">     }</span>
<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[3., -1], [-1., 3.]]), \</span>
<span class="sd">                          b=ivy.array([[2., 1.], [1., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; upper = ivy.Container(a=1, b=-1)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_roll(x, upper=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[3., 3.],</span>
<span class="sd">                     [-1., -1.]]),</span>
<span class="sd">        b: ivy.array([[1., 1.],</span>
<span class="sd">                      [1., 2.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cholesky"><a class="viewcode-back" href="../../../container/container_methods/cholesky.html#ivy.container.container_methods.cholesky">[docs]</a><span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">upper</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cholesky. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.cholesky also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container having shape (..., M, M) and whose innermost two dimensions</span>
<span class="sd">        form square symmetric positive-definite matrices. Should have a</span>
<span class="sd">        floating-point data type.</span>
<span class="sd">    upper</span>
<span class="sd">        If True, the result must be the upper-triangular Cholesky factor U. If</span>
<span class="sd">        False, the result must be the lower-triangular Cholesky factor L.</span>
<span class="sd">        Default: False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the Cholesky factors for each square matrix. If upper</span>
<span class="sd">        is False, the returned container must contain lower-triangular matrices;</span>
<span class="sd">        otherwise, the returned container must contain upper-triangular matrices.</span>
<span class="sd">        The returned container must have a floating-point data type determined by</span>
<span class="sd">        Type Promotion Rules and must have the same shape as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[3., -1],[-1., 3.]]), \</span>
<span class="sd">                          b=ivy.array([[2., 1.],[1., 1.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.cholesky(upper=&#39;false&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[1.73, -0.577],</span>
<span class="sd">                        [0., 1.63]]),</span>
<span class="sd">        b: ivy.array([[1.41, 0.707],</span>
<span class="sd">                        [0., 0.707]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_cross"><a class="viewcode-back" href="../../../container/container_methods/static_cross.html#ivy.container.container_methods.static_cross">[docs]</a><span class="k">def</span> <span class="nf">static_cross</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cross.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.cross also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis (dimension) of x1 and x2 containing the vectors for which to</span>
<span class="sd">        compute the cross product.vIf set to -1, the function computes the</span>
<span class="sd">        cross product for vectors defined by the last axis (dimension).</span>
<span class="sd">        Default: -1.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([9., 0., 3.])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([1., 1., 0.]), b=ivy.array([1., 0., 1.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-3., 3., 9.]),</span>
<span class="sd">        b: ivy.array([0., -6., 0.])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = x = ivy.Container(a=ivy.array([5., 0., 0.]), b=ivy.array([0., 0., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 7., 0.]), b=ivy.array([3., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 35.]),</span>
<span class="sd">        b: ivy.array([0., 6., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cross"><a class="viewcode-back" href="../../../container/container_methods/cross.html#ivy.container.container_methods.cross">[docs]</a><span class="k">def</span> <span class="nf">cross</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cross.</span>
<span class="sd">    This method simply wraps the function, and so the docstring</span>
<span class="sd">    for ivy.cross also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        first input array. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        second input array. Must be compatible with ``self``</span>
<span class="sd">        (see :ref:`broadcasting`). Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis (dimension) of x1 and x2 containing the vectors for which to</span>
<span class="sd">        compute (default: -1) the cross product.vIf set to -1, the function</span>
<span class="sd">        computes the cross product for vectors defined by the last axis (dimension).</span>
<span class="sd">        Default: -1.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the element-wise products. The returned array must have</span>
<span class="sd">        a data type determined by :ref:`type-promotion`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5., 0., 0.]), b=ivy.array([0., 0., 2.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 7., 0.]), b=ivy.array([3., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 35.]),</span>
<span class="sd">        b: ivy.array([0., 6., 0.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_det"><a class="viewcode-back" href="../../../container/container_methods/static_det.html#ivy.container.container_methods.static_det">[docs]</a><span class="k">def</span> <span class="nf">static_det</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="det"><a class="viewcode-back" href="../../../container/container_methods/det.html#ivy.container.container_methods.det">[docs]</a><span class="k">def</span> <span class="nf">det</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_diagonal"><a class="viewcode-back" href="../../../container/container_methods/static_diagonal.html#ivy.container.container_methods.static_diagonal">[docs]</a><span class="k">def</span> <span class="nf">static_diagonal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="diagonal"><a class="viewcode-back" href="../../../container/container_methods/diagonal.html#ivy.container.container_methods.diagonal">[docs]</a><span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="eigh"><a class="viewcode-back" href="../../../container/container_methods/eigh.html#ivy.container.container_methods.eigh">[docs]</a><span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NamedTuple</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x_</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">if</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_array</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">else</span> <span class="n">x_</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">static_inv</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="inv"><a class="viewcode-back" href="../../../container/container_methods/inv.html#ivy.container.container_methods.inv">[docs]</a><span class="k">def</span> <span class="nf">inv</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_matrix_norm"><a class="viewcode-back" href="../../../container/container_methods/static_matrix_norm.html#ivy.container.container_methods.static_matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span> <span class="s2">&quot;nuc&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.matrix_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.matrix_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array.</span>
<span class="sd">    ord</span>
<span class="sd">        Order of the norm. Default is 2.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are normed over are left in the</span>
<span class="sd">        result as dimensions with size one. With this option the result will</span>
<span class="sd">        broadcast correctly against the original x. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Matrix norm of the array at specified axes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="matrix_norm"><a class="viewcode-back" href="../../../container/container_methods/matrix_norm.html#ivy.container.container_methods.matrix_norm">[docs]</a><span class="k">def</span> <span class="nf">matrix_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span> <span class="s2">&quot;nuc&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;fro&quot;</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.matrix_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.matrix_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input array.</span>
<span class="sd">    ord</span>
<span class="sd">        Order of the norm. Default is 2.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are normed over are left in the</span>
<span class="sd">        result as dimensions with size one. With this option the result will</span>
<span class="sd">        broadcast correctly against the original x. Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Matrix norm of the array at specified axes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_matrix_power"><a class="viewcode-back" href="../../../container/container_methods/static_matrix_power.html#ivy.container.container_methods.static_matrix_power">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_power</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="matrix_power"><a class="viewcode-back" href="../../../container/container_methods/matrix_power.html#ivy.container.container_methods.matrix_power">[docs]</a><span class="k">def</span> <span class="nf">matrix_power</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_matrix_rank"><a class="viewcode-back" href="../../../container/container_methods/static_matrix_rank.html#ivy.container.container_methods.static_matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_rank</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.matrix_rank.</span>
<span class="sd">    This method returns the rank (i.e., number of non-zero singular values)</span>
<span class="sd">    of a matrix (or a stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container having shape ``(..., M, N)`` and whose innermost</span>
<span class="sd">        two dimensions form ``MxN`` matrices. Should have a floating-point data</span>
<span class="sd">        type.</span>
<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values. Singular values</span>
<span class="sd">        approximately less than or equal to ``rtol * largest_singular_value`` are</span>
<span class="sd">        set to zero. If a ``float``, the value is equivalent to a zero-dimensional</span>
<span class="sd">        array having a floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``) and must be broadcast against each matrix. If an</span>
<span class="sd">        ``array``, must have a floating-point data type and must be compatible with</span>
<span class="sd">        ``shape(x)[:-2]`` (see:ref:`broadcasting`). If ``None``, the default value</span>
<span class="sd">        is ``max(M, N) * eps``, where ``eps`` must be the machine epsilon associated</span>
<span class="sd">        with the floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``).</span>
<span class="sd">        Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the ranks. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and must have</span>
<span class="sd">        shape ``(...)`` (i.e., must have a shape equal to ``shape(x)[:-2]``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code: `ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 0.], [0., 1.]]), \</span>
<span class="sd">                          b=ivy.array([[1., 0.], [0., 0.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_matrix_rank(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(2.),</span>
<span class="sd">        b: ivy.array(1.)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="matrix_rank"><a class="viewcode-back" href="../../../container/container_methods/matrix_rank.html#ivy.container.container_methods.matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">matrix_rank</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.matrix_rank.</span>
<span class="sd">    This method returns the rank (i.e., number of non-zero singular values)</span>
<span class="sd">    of a matrix (or a stack of matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container having shape ``(..., M, N)`` and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices. Should have a floating-point data type.</span>
<span class="sd">    rtol</span>
<span class="sd">        relative tolerance for small singular values. Singular values approximately</span>
<span class="sd">        less than or equal to ``rtol * largest_singular_value`` are set to zero. If</span>
<span class="sd">        a ``float``, the value is equivalent to a zero-dimensional array having a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` (as applied to</span>
<span class="sd">        ``x``) and must be broadcast against each matrix. If an ``array``, must have</span>
<span class="sd">        a floating-point data type and must be compatible with ``shape(x)[:-2]``</span>
<span class="sd">        (see :ref:`broadcasting`). If ``None``, the default value is</span>
<span class="sd">        ``max(M, N) * eps``, where ``eps`` must be the machine epsilon associated</span>
<span class="sd">        with the floating-point data type determined by :ref:`type-promotion`</span>
<span class="sd">        (as applied to ``x``). Default: ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the ranks. The returned array must have a</span>
<span class="sd">        floating-point data type determined by :ref:`type-promotion` and must have</span>
<span class="sd">        shape ``(...)`` (i.e., must have a shape equal to ``shape(x)[:-2]``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code: `ivy.Container` input:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[1., 0.], [0., 1.]]), \</span>
<span class="sd">                            b=ivy.array([[1., 0.], [0., 0.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.matrix_rank()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(2),</span>
<span class="sd">        b: ivy.array(1)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_matrix_transpose"><a class="viewcode-back" href="../../../container/container_methods/static_matrix_transpose.html#ivy.container.container_methods.static_matrix_transpose">[docs]</a><span class="k">def</span> <span class="nf">static_matrix_transpose</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="matrix_transpose"><a class="viewcode-back" href="../../../container/container_methods/matrix_transpose.html#ivy.container.container_methods.matrix_transpose">[docs]</a><span class="k">def</span> <span class="nf">matrix_transpose</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_outer"><a class="viewcode-back" href="../../../container/container_methods/static_outer.html#ivy.container.container_methods.static_outer">[docs]</a><span class="k">def</span> <span class="nf">static_outer</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="outer"><a class="viewcode-back" href="../../../container/container_methods/outer.html#ivy.container.container_methods.outer">[docs]</a><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_qr"><a class="viewcode-back" href="../../../container/container_methods/static_qr.html#ivy.container.container_methods.static_qr">[docs]</a><span class="k">def</span> <span class="nf">static_qr</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reduced&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="qr"><a class="viewcode-back" href="../../../container/container_methods/qr.html#ivy.container.container_methods.qr">[docs]</a><span class="k">def</span> <span class="nf">qr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reduced&quot;</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_slogdet"><a class="viewcode-back" href="../../../container/container_methods/static_slogdet.html#ivy.container.container_methods.static_slogdet">[docs]</a><span class="k">def</span> <span class="nf">static_slogdet</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="slogdet"><a class="viewcode-back" href="../../../container/container_methods/slogdet.html#ivy.container.container_methods.slogdet">[docs]</a><span class="k">def</span> <span class="nf">slogdet</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_solve"><a class="viewcode-back" href="../../../container/container_methods/static_solve.html#ivy.container.container_methods.static_solve">[docs]</a><span class="k">def</span> <span class="nf">static_solve</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../container/container_methods/solve.html#ivy.container.container_methods.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_svd"><a class="viewcode-back" href="../../../container/container_methods/static_svd.html#ivy.container.container_methods.static_svd">[docs]</a><span class="k">def</span> <span class="nf">static_svd</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">full_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;svd&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">full_matrices</span><span class="o">=</span><span class="n">full_matrices</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="c1"># Unsure</span>
<div class="viewcode-block" id="svd"><a class="viewcode-back" href="../../../container/container_methods/svd.html#ivy.container.container_methods.svd">[docs]</a><span class="k">def</span> <span class="nf">svd</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">full_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_svd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="p">,</span>
        <span class="n">full_matrices</span><span class="o">=</span><span class="n">full_matrices</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">static_svdvals</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="svdvals"><a class="viewcode-back" href="../../../container/container_methods/svdvals.html#ivy.container.container_methods.svdvals">[docs]</a><span class="k">def</span> <span class="nf">svdvals</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_tensordot"><a class="viewcode-back" href="../../../container/container_methods/static_tensordot.html#ivy.container.container_methods.static_tensordot">[docs]</a><span class="k">def</span> <span class="nf">static_tensordot</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tensordot"><a class="viewcode-back" href="../../../container/container_methods/tensordot.html#ivy.container.container_methods.tensordot">[docs]</a><span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_trace"><a class="viewcode-back" href="../../../container/container_methods/static_trace.html#ivy.container.container_methods.static_trace">[docs]</a><span class="k">def</span> <span class="nf">static_trace</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="trace"><a class="viewcode-back" href="../../../container/container_methods/trace.html#ivy.container.container_methods.trace">[docs]</a><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_vecdot"><a class="viewcode-back" href="../../../container/container_methods/static_vecdot.html#ivy.container.container_methods.static_vecdot">[docs]</a><span class="k">def</span> <span class="nf">static_vecdot</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="vecdot"><a class="viewcode-back" href="../../../container/container_methods/vecdot.html#ivy.container.container_methods.vecdot">[docs]</a><span class="k">def</span> <span class="nf">vecdot</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_vector_norm"><a class="viewcode-back" href="../../../container/container_methods/static_vector_norm.html#ivy.container.container_methods.static_vector_norm">[docs]</a><span class="k">def</span> <span class="nf">static_vector_norm</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.vector_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.vector_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        If an integer, ``axis`` specifies the axis (dimension)</span>
<span class="sd">        along which to compute vector norms. If an n-tuple,</span>
<span class="sd">        ``axis`` specifies the axes (dimensions) along</span>
<span class="sd">        which to compute batched vector norms. If ``None``, the</span>
<span class="sd">         vector norm must be computed over all array values</span>
<span class="sd">         (i.e., equivalent to computing the vector norm of</span>
<span class="sd">        a flattened array). Negative indices must be</span>
<span class="sd">        supported. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the axes (dimensions) specified by ``axis``</span>
<span class="sd">        must be included in the result as singleton dimensions,</span>
<span class="sd">        and, accordingly, the result must be compatible</span>
<span class="sd">        with the input array (see :ref:`broadcasting`). Otherwise,</span>
<span class="sd">        if ``False``, the axes (dimensions) specified by ``axis`` must</span>
<span class="sd">        not be included in the result. Default: ``False``.</span>
<span class="sd">    ord</span>
<span class="sd">        order of the norm. The following mathematical norms must be supported:</span>

<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | ord              | description                |</span>
<span class="sd">        +==================+============================+</span>
<span class="sd">        | 1                | L1-norm (Manhattan)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | 2                | L2-norm (Euclidean)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | inf              | infinity norm              |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | (int,float &gt;= 1) | p-norm                     |</span>
<span class="sd">        +------------------+----------------------------+</span>

<span class="sd">        The following non-mathematical &quot;norms&quot; must be supported:</span>

<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | ord              | description                    |</span>
<span class="sd">        +==================+================================+</span>
<span class="sd">        | 0                | sum(a != 0)                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -1               | 1./sum(1./abs(a))              |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -2               | 1./sqrt(sum(1./abs(a)/*/*2))   | </span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -inf             | min(abs(a))                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | (int,float &lt; 1)  | sum(abs(a)/*/*ord)/*/*(1./ord) |</span>
<span class="sd">        +------------------+--------------------------------+</span>

<span class="sd">        Default: ``2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the vector norms. If ``axis`` is</span>
<span class="sd">        ``None``, the returned array must be a zero-dimensional</span>
<span class="sd">        array containing a vector norm. If ``axis`` is</span>
<span class="sd">        a scalar value (``int`` or ``float``), the returned array</span>
<span class="sd">        must have a rank which is one less than the rank of ``x``.</span>
<span class="sd">        If ``axis`` is a ``n``-tuple, the returned array must have</span>
<span class="sd">         a rank which is ``n`` less than the rank of ``x``. The returned</span>
<span class="sd">        array must have a floating-point data type determined</span>
<span class="sd">        by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="vector_norm"><a class="viewcode-back" href="../../../container/container_methods/vector_norm.html#ivy.container.container_methods.vector_norm">[docs]</a><span class="k">def</span> <span class="nf">vector_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">ord</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.vector_norm.</span>
<span class="sd">    This method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.vector_norm also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        If an integer, ``axis`` specifies the axis (dimension)</span>
<span class="sd">        along which to compute vector norms. If an n-tuple, ``axis``</span>
<span class="sd">        specifies the axes (dimensions) along which to compute</span>
<span class="sd">        batched vector norms. If ``None``, the vector norm must be</span>
<span class="sd">        computed over all array values (i.e., equivalent to computing</span>
<span class="sd">        the vector norm of a flattened array). Negative indices must</span>
<span class="sd">        be supported. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the axes (dimensions) specified by ``axis`` must</span>
<span class="sd">        be included in the result as singleton dimensions, and, accordingly,</span>
<span class="sd">        the result must be compatible with the input array</span>
<span class="sd">        (see :ref:`broadcasting`).Otherwise, if ``False``, the axes</span>
<span class="sd">        (dimensions) specified by ``axis`` must not be included in</span>
<span class="sd">        the result. Default: ``False``.</span>
<span class="sd">    ord</span>
<span class="sd">        order of the norm. The following mathematical norms must be supported:</span>

<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | ord              | description                |</span>
<span class="sd">        +==================+============================+</span>
<span class="sd">        | 1                | L1-norm (Manhattan)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | 2                | L2-norm (Euclidean)        |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | inf              | infinity norm              |</span>
<span class="sd">        +------------------+----------------------------+</span>
<span class="sd">        | (int,float &gt;= 1) | p-norm                     |</span>
<span class="sd">        +------------------+----------------------------+</span>

<span class="sd">        The following non-mathematical &quot;norms&quot; must be supported:</span>

<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | ord              | description                    |</span>
<span class="sd">        +==================+================================+</span>
<span class="sd">        | 0                | sum(a != 0)                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -1               | 1./sum(1./abs(a))              |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -2               | 1./sqrt(sum(1./abs(a)/*/*2))   | </span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | -inf             | min(abs(a))                    |</span>
<span class="sd">        +------------------+--------------------------------+</span>
<span class="sd">        | (int,float &lt; 1)  | sum(abs(a)/*/*ord)/*/*(1./ord) |</span>
<span class="sd">        +------------------+--------------------------------+</span>

<span class="sd">        Default: ``2``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must</span>
<span class="sd">        have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an array containing the vector norms. If ``axis`` is ``None``,</span>
<span class="sd">        the returned array must be a zero-dimensional array containing</span>
<span class="sd">        a vector norm. If ``axis`` is a scalar value (``int`` or ``float``),</span>
<span class="sd">        the returned array must have a rank which is one less than the</span>
<span class="sd">        rank of ``x``. If ``axis`` is a ``n``-tuple, the returned</span>
<span class="sd">        array must have a rank which is ``n`` less than the rank of</span>
<span class="sd">        ``x``. The returned array must have a floating-point data type</span>
<span class="sd">        determined by :ref:`type-promotion`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_vector_to_skew_symmetric_matrix"><a class="viewcode-back" href="../../../container/container_methods/static_vector_to_skew_symmetric_matrix.html#ivy.container.container_methods.static_vector_to_skew_symmetric_matrix">[docs]</a><span class="k">def</span> <span class="nf">static_vector_to_skew_symmetric_matrix</span><span class="p">(</span>
    <span class="n">vector</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="vector_to_skew_symmetric_matrix"><a class="viewcode-back" href="../../../container/container_methods/vector_to_skew_symmetric_matrix.html#ivy.container.container_methods.vector_to_skew_symmetric_matrix">[docs]</a><span class="k">def</span> <span class="nf">vector_to_skew_symmetric_matrix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.losses</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<div class="viewcode-block" id="static_cross_entropy"><a class="viewcode-back" href="../../../container/container_methods/static_cross_entropy.html#ivy.container.container_methods.static_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">static_cross_entropy</span><span class="p">(</span>
    <span class="n">true</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.cross_entropy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.cross_entropy also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    true</span>
<span class="sd">        input array or container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``,</span>
<span class="sd">        the cross-entropy will be computed along the last dimension.</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 0, 1]), b=ivy.array([1, 1, 0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(1.20397282),</span>
<span class="sd">        b: ivy.array(1.83258148)</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Array` and :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(1.20397282),</span>
<span class="sd">        b: ivy.array(1.60943794)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cross_entropy"><a class="viewcode-back" href="../../../container/container_methods/cross_entropy.html#ivy.container.container_methods.cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.cross_entropy. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.cross_entropy also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``,</span>
<span class="sd">        the cross-entropy will be computed along the last dimension.</span>
<span class="sd">        Default: ``-1``.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array(0.5108256),</span>
<span class="sd">        b:ivy.array(1.609438)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_binary_cross_entropy"><a class="viewcode-back" href="../../../container/container_methods/static_binary_cross_entropy.html#ivy.container.container_methods.static_binary_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">static_binary_cross_entropy</span><span class="p">(</span>
    <span class="n">true</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.binary_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.binary_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    true</span>
<span class="sd">        input array or container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing Predicted labels.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The binary cross entropy between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_binary_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.511, 0.223, 0.357]),</span>
<span class="sd">        b: ivy.array([1.61, 0.223, 1.61])</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Array` and :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.7, 0.8, 0.2]),b=ivy.array([0.2, 0.6, 0.7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_binary_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.357, 0.223, 0.223]),</span>
<span class="sd">        b: ivy.array([1.61, 0.511, 1.2])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="binary_cross_entropy"><a class="viewcode-back" href="../../../container/container_methods/binary_cross_entropy.html#ivy.container.container_methods.binary_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">binary_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.binary_cross_entropy. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.binary_cross_entropy also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container containing true labels.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing Predicted labels.</span>
<span class="sd">    epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The binary cross entropy between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.binary_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.511, 0.223, 0.357]),</span>
<span class="sd">        b: ivy.array([1.61, 0.223, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_sparse_cross_entropy"><a class="viewcode-back" href="../../../container/container_methods/static_sparse_cross_entropy.html#ivy.container.container_methods.static_sparse_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">static_sparse_cross_entropy</span><span class="p">(</span>
    <span class="n">true</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sparse_cross_entropy. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.sparse_cross_entropy</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    true</span>
<span class="sd">        input array or container containing the true labels as logits.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels as logits.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``, the</span>
<span class="sd">        cross-entropy will be computed along the last dimension. Default: ``-1``.</span>
<span class="sd">        epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The sparse cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_sparse_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.61, 0.511, 0.511]),</span>
<span class="sd">        b: ivy.array([0.223, 0.223, 1.61])</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Array` and :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([1 , 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.7, 0.8, 0.2]),b=ivy.array([0.2, 0.6, 0.7]))</span>
<span class="sd">    &gt;&gt;&gt; z = ivy.Container.static_sparse_cross_entropy(x, y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.223, 0.223, 0.357]),</span>
<span class="sd">        b: ivy.array([0.511, 0.511, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sparse_cross_entropy"><a class="viewcode-back" href="../../../container/container_methods/sparse_cross_entropy.html#ivy.container.container_methods.sparse_cross_entropy">[docs]</a><span class="k">def</span> <span class="nf">sparse_cross_entropy</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sparse_cross_entropy. This</span>
<span class="sd">    method simply wraps the function, and so the docstring for</span>
<span class="sd">    ivy.sparse_cross_entropy also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container containing the true labels as logits.</span>
<span class="sd">    pred</span>
<span class="sd">        input array or container containing the predicted labels as logits.</span>
<span class="sd">    axis</span>
<span class="sd">        the axis along which to compute the cross-entropy. If axis is ``-1``, the</span>
<span class="sd">        cross-entropy will be computed along the last dimension. Default: ``-1``.</span>
<span class="sd">        epsilon</span>
<span class="sd">        a float in [0.0, 1.0] specifying the amount of smoothing when calculating</span>
<span class="sd">        the loss. If epsilon is ``0``, no smoothing will be applied.</span>
<span class="sd">        Default: ``1e-7``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The sparse cross-entropy loss between the given distributions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([1, 0, 0]),b=ivy.array([0, 0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; z = x.sparse_cross_entropy(y)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1.61, 0.511, 0.511]),</span>
<span class="sd">        b: ivy.array([0.223, 0.223, 1.61])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.manipulation</span>
<span class="c1"># For Review</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_concat"><a class="viewcode-back" href="../../../container/container_methods/static_concat.html#ivy.container.container_methods.static_concat">[docs]</a><span class="k">def</span> <span class="nf">static_concat</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.concat. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.concat also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="concat"><a class="viewcode-back" href="../../../container/container_methods/concat.html#ivy.container.container_methods.concat">[docs]</a><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.concat. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.concat also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_expand_dims"><a class="viewcode-back" href="../../../container/container_methods/static_expand_dims.html#ivy.container.container_methods.static_expand_dims">[docs]</a><span class="k">def</span> <span class="nf">static_expand_dims</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.expand_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.expand_dims also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        position where a new axis (dimension) of size one will be added. If an</span>
<span class="sd">        element of the container has the rank of ``N``, then the ``axis`` needs</span>
<span class="sd">        to be between ``[-N-1, N]``. Default: ``0``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of ``x``, but with the dimensions of</span>
<span class="sd">        its elements added by one in a given ``axis``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1.]), \</span>
<span class="sd">                          b=ivy.array([3., 4.]), \</span>
<span class="sd">                          c=ivy.array([6., 7.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_expand_dims(x, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0.],</span>
<span class="sd">                      [1.]]),</span>
<span class="sd">        b: ivy.array([[3.],</span>
<span class="sd">                      [4.]]),</span>
<span class="sd">        c: ivy.array([[6.],</span>
<span class="sd">                      [7.]])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]), \</span>
<span class="sd">                          c=ivy.array([6., 7., 8.]))</span>
<span class="sd">    &gt;&gt;&gt; container_axis = ivy.Container(a=0, b=-1, c=(0,1))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_expand_dims(x, axis=container_axis)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0., 1., 2.]]),</span>
<span class="sd">        b: ivy.array([[3.],</span>
<span class="sd">                      [4.],</span>
<span class="sd">                      [5.]]),</span>
<span class="sd">        c: ivy.array([[[6., 7., 8.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="expand_dims"><a class="viewcode-back" href="../../../container/container_methods/expand_dims.html#ivy.container.container_methods.expand_dims">[docs]</a><span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.expand_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.expand_dims also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        position where a new axis (dimension) of size one will be added. If an</span>
<span class="sd">        element of the container has the rank of ``N``, the ``axis`` needs to</span>
<span class="sd">        be between ``[-N-1, N]``. Default: ``0``.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of ``self``, but with the dimensions of</span>
<span class="sd">        its elements added by one in a given ``axis``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0., 1.], \</span>
<span class="sd">                                       [2., 3.]]), \</span>
<span class="sd">                          b=ivy.array([[4., 5.], \</span>
<span class="sd">                                       [6., 7.]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.expand_dims(axis=1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[[0., 1.]],</span>
<span class="sd">                      [[2., 3.]]]),</span>
<span class="sd">        b: ivy.array([[[4., 5.]],</span>
<span class="sd">                      [[6., 7.]]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_split"><a class="viewcode-back" href="../../../container/container_methods/static_split.html#ivy.container.container_methods.static_split">[docs]</a><span class="k">def</span> <span class="nf">static_split</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_or_size_splits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">with_remainder</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.split. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        array to be divided into sub-arrays.</span>
<span class="sd">    num_or_size_splits</span>
<span class="sd">        Number of equal arrays to divide the array into along the given axis if an</span>
<span class="sd">        integer. The size of each split element if a sequence of integers. Default</span>
<span class="sd">        is to divide into as many 1-dimensional arrays as the axis dimension.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to split, default is 0.</span>
<span class="sd">    with_remainder</span>
<span class="sd">        If the tensor does not split evenly, then store the last remainder entry.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A container with list of sub-arrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
        <span class="s2">&quot;split&quot;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">num_or_size_splits</span><span class="o">=</span><span class="n">num_or_size_splits</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">with_remainder</span><span class="o">=</span><span class="n">with_remainder</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../../container/container_methods/split.html#ivy.container.container_methods.split">[docs]</a><span class="k">def</span> <span class="nf">split</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_or_size_splits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">with_remainder</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.split. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.split also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        array to be divided into sub-arrays.</span>
<span class="sd">    num_or_size_splits</span>
<span class="sd">        Number of equal arrays to divide the array into along the given axis if an</span>
<span class="sd">        integer. The size of each split element if a sequence of integers. Default</span>
<span class="sd">        is to divide into as many 1-dimensional arrays as the axis dimension.</span>
<span class="sd">    axis</span>
<span class="sd">        The axis along which to split, default is 0.</span>
<span class="sd">    with_remainder</span>
<span class="sd">        If the tensor does not split evenly, then store the last remainder entry.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains will</span>
<span class="sd">        be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        A container with list of sub-arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2, 5, 9]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.split()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2], [5], [9]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_split</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_or_size_splits</span><span class="o">=</span><span class="n">num_or_size_splits</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">with_remainder</span><span class="o">=</span><span class="n">with_remainder</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">static_permute_dims</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.permute_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.permute_dims also applies</span>
<span class="sd">    to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="permute_dims"><a class="viewcode-back" href="../../../container/container_methods/permute_dims.html#ivy.container.container_methods.permute_dims">[docs]</a><span class="k">def</span> <span class="nf">permute_dims</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.permute_dims. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.permute_dims also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_flip"><a class="viewcode-back" href="../../../container/container_methods/static_flip.html#ivy.container.container_methods.static_flip">[docs]</a><span class="k">def</span> <span class="nf">static_flip</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.flip. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.flip also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="flip"><a class="viewcode-back" href="../../../container/container_methods/flip.html#ivy.container.container_methods.flip">[docs]</a><span class="k">def</span> <span class="nf">flip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.flip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.flip also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_reshape"><a class="viewcode-back" href="../../../container/container_methods/static_reshape.html#ivy.container.container_methods.static_reshape">[docs]</a><span class="k">def</span> <span class="nf">static_reshape</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.reshape. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.reshape also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>

<span class="sd">    shape</span>
<span class="sd">        The new shape should be compatible with the original shape.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean indicating whether or not to copy the input array.</span>
<span class="sd">        If True, the function must always copy.</span>
<span class="sd">        If False, the function must never copy and must</span>
<span class="sd">        raise a ValueError in case a copy would be necessary.</span>
<span class="sd">        If None, the function must reuse existing memory buffer if possible</span>
<span class="sd">        and copy otherwise. Default: None.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2, 3, 4, 5]), \</span>
<span class="sd">                          b=ivy.array([0, 1, 2, 3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_reshape(x, (3,2))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1],</span>
<span class="sd">                      [2, 3],</span>
<span class="sd">                      [4, 5]]),</span>
<span class="sd">        b: ivy.array([[0, 1],</span>
<span class="sd">                      [2, 3],</span>
<span class="sd">                      [4, 5]])</span>
<span class="sd">    }</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../container/container_methods/reshape.html#ivy.container.container_methods.reshape">[docs]</a><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.reshape. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.reshape also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    shape</span>
<span class="sd">        The new shape should be compatible with the original shape.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    copy</span>
<span class="sd">        boolean indicating whether or not to copy the input array.</span>
<span class="sd">        If True, the function must always copy.</span>
<span class="sd">        If False, the function must never copy and must</span>
<span class="sd">        raise a ValueError in case a copy would be necessary.</span>
<span class="sd">        If None, the function must reuse existing memory buffer if possible</span>
<span class="sd">        and copy otherwise. Default: None.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``self``</span>
<span class="sd">        and elements as ``self``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2, 3, 4, 5]), \</span>
<span class="sd">                          b=ivy.array([0, 1, 2, 3, 4, 5]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.reshape((2,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0, 1, 2],</span>
<span class="sd">                      [3, 4, 5]]),</span>
<span class="sd">        b: ivy.array([[0, 1, 2],</span>
<span class="sd">                      [3, 4, 5]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_roll"><a class="viewcode-back" href="../../../container/container_methods/static_roll.html#ivy.container.container_methods.static_roll">[docs]</a><span class="k">def</span> <span class="nf">static_roll</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.roll. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.roll also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    shift</span>
<span class="sd">        number of places by which the elements are shifted. If ``shift`` is a tuple,</span>
<span class="sd">        then ``axis`` must be a tuple of the same size, and each of the given axes</span>
<span class="sd">        must be shifted by the corresponding element in ``shift``. If ``shift`` is</span>
<span class="sd">        an ``int`` and ``axis`` a tuple, then the same ``shift`` must be used for</span>
<span class="sd">        all specified axes. If a shift is positivclipe, then array elements must be</span>
<span class="sd">        shifted positively (toward larger indices) along the dimension of ``axis``.</span>
<span class="sd">        If a shift is negative, then array elements must be shifted negatively</span>
<span class="sd">        (toward smaller indices) along the dimension of ``axis``.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which elements to shift. If ``axis`` is ``None``, the</span>
<span class="sd">        array must be flattened, shifted, and then restored to its original shape.</span>
<span class="sd">        Default ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``x`` and whose elements,</span>
<span class="sd">        relative to ``x``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_roll(x, 1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., 1.]),</span>
<span class="sd">        b: ivy.array([5., 3., 4.])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; shift = ivy.Container(a=1, b=-1)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_roll(x, shift)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., 1.]),</span>
<span class="sd">        b: ivy.array([4., 5., 3.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../../container/container_methods/roll.html#ivy.container.container_methods.roll">[docs]</a><span class="k">def</span> <span class="nf">roll</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.roll. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.roll also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    shift</span>
<span class="sd">        number of places by which the elements are shifted. If ``shift`` is a tuple,</span>
<span class="sd">        then ``axis`` must be a tuple of the same size, and each of the given axes</span>
<span class="sd">        must be shifted by the corresponding element in ``shift``. If ``shift`` is</span>
<span class="sd">        an ``int`` and ``axis`` a tuple, then the same ``shift`` must be used for</span>
<span class="sd">        all specified axes. If a shift is positive, then array elements must be</span>
<span class="sd">        shifted positively (toward larger indices) along the dimension of ``axis``.</span>
<span class="sd">        If a shift is negative, then array elements must be shifted negatively</span>
<span class="sd">        (toward smaller indices) along the dimension of ``axis``.</span>
<span class="sd">    axis</span>
<span class="sd">        axis (or axes) along which elements to shift. If ``axis`` is ``None``, the</span>
<span class="sd">        array must be flattened, shifted, and then restored to its original shape.</span>
<span class="sd">        Default ``None``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        an output container having the same data type as ``self`` and whose</span>
<span class="sd">        elements, relative to ``self``, are shifted.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.roll(1)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2., 0., 1.]),</span>
<span class="sd">        b: ivy.array([5., 3., 4.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_squeeze"><a class="viewcode-back" href="../../../container/container_methods/static_squeeze.html#ivy.container.container_methods.static_squeeze">[docs]</a><span class="k">def</span> <span class="nf">static_squeeze</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.squeeze. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.squeeze also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../../container/container_methods/squeeze.html#ivy.container.container_methods.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.squeeze. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.squeeze also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[10.], [11.]]]), \</span>
<span class="sd">                          b=ivy.array([[[11.], [12.]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.squeeze(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10., 11.]]),</span>
<span class="sd">        b: ivy.array([[11., 12.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[[10.], [11.]]]), \</span>
<span class="sd">                          b=ivy.array([[[11.], [12.]]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.squeeze(0)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.], [11.]]),</span>
<span class="sd">        b: ivy.array([[11.], [12.]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_stack"><a class="viewcode-back" href="../../../container/container_methods/static_stack.html#ivy.container.container_methods.static_stack">[docs]</a><span class="k">def</span> <span class="nf">static_stack</span><span class="p">(</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.stack. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.stack also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="stack"><a class="viewcode-back" href="../../../container/container_methods/stack.html#ivy.container.container_methods.stack">[docs]</a><span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">xs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.stack. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.stack</span>
<span class="sd">    also applies to this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_repeat"><a class="viewcode-back" href="../../../container/container_methods/static_repeat.html#ivy.container.container_methods.static_repeat">[docs]</a><span class="k">def</span> <span class="nf">static_repeat</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">repeats</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.repeat. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.repeat also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_repeat(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1., 1., 2., 2.]),</span>
<span class="sd">        b: ivy.array([3., 3., 4., 4., 5., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../container/container_methods/repeat.html#ivy.container.container_methods.repeat">[docs]</a><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">repeats</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.repeat. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.repeat</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.repeat(2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0., 0., 1., 1., 2., 2.]),</span>
<span class="sd">        b: ivy.array([3., 3., 4., 4., 5., 5.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_tile"><a class="viewcode-back" href="../../../container/container_methods/static_tile.html#ivy.container.container_methods.static_tile">[docs]</a><span class="k">def</span> <span class="nf">static_tile</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">reps</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.tile. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.tile also applies to</span>
<span class="sd">    this method with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_tile((2,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[0,1,0,1,0,1],</span>
<span class="sd">                      [2,3,2,3,2,3],</span>
<span class="sd">                      [0,1,0,1,0,1],</span>
<span class="sd">                      [2,3,2,3,2,3]]),</span>
<span class="sd">        b: ivy.array([[4,5,4,5,4,5],</span>
<span class="sd">                      [4,5,4,5,4,5]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="tile"><a class="viewcode-back" href="../../../container/container_methods/tile.html#ivy.container.container_methods.tile">[docs]</a><span class="k">def</span> <span class="nf">tile</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">reps</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.tile. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.tile also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0, 1], [2,3]]), b=ivy.array([[4, 5]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.tile((2,3))</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (&lt;classivy.array.array.Array&gt;shape=[4,6]),</span>
<span class="sd">        b: (&lt;classivy.array.array.Array&gt;shape=[2,6])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_constant_pad"><a class="viewcode-back" href="../../../container/container_methods/static_constant_pad.html#ivy.container.container_methods.static_constant_pad">[docs]</a><span class="k">def</span> <span class="nf">static_constant_pad</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.constant_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.constant_pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="constant_pad"><a class="viewcode-back" href="../../../container/container_methods/constant_pad.html#ivy.container.container_methods.constant_pad">[docs]</a><span class="k">def</span> <span class="nf">constant_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.constant_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.constant_pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_zero_pad"><a class="viewcode-back" href="../../../container/container_methods/static_zero_pad.html#ivy.container.container_methods.static_zero_pad">[docs]</a><span class="k">def</span> <span class="nf">static_zero_pad</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.zero_pad. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.zero_pad also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="zero_pad"><a class="viewcode-back" href="../../../container/container_methods/zero_pad.html#ivy.container.container_methods.zero_pad">[docs]</a><span class="k">def</span> <span class="nf">zero_pad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">pad_width</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.zero_pad. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.zero_pad also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_swapaxes"><a class="viewcode-back" href="../../../container/container_methods/static_swapaxes.html#ivy.container.container_methods.static_swapaxes">[docs]</a><span class="k">def</span> <span class="nf">static_swapaxes</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.swapaxes. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.swapaxes also applies to</span>
<span class="sd">    this method with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="swapaxes"><a class="viewcode-back" href="../../../container/container_methods/swapaxes.html#ivy.container.container_methods.swapaxes">[docs]</a><span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">axis0</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.swapaxes. This method simply wraps</span>
<span class="sd">    the function, and so the docstring for ivy.swapaxes also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_clip"><a class="viewcode-back" href="../../../container/container_methods/static_clip.html#ivy.container.container_methods.static_clip">[docs]</a><span class="k">def</span> <span class="nf">static_clip</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">x_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.clip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.clip also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container containing elements to clip.</span>
<span class="sd">    x_min</span>
<span class="sd">        Minimum value.</span>
<span class="sd">    x_max</span>
<span class="sd">        Maximum value.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of x, but where values &lt; x_min are replaced</span>
<span class="sd">        with x_min, and those &gt; x_max with x_max.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_clip(x, 1., 5.)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 1., 2.]),</span>
<span class="sd">        b: ivy.array([3., 4., 5.])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), \</span>
<span class="sd">                          b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; x_min = ivy.Container(a=1, b=-1)</span>
<span class="sd">    &gt;&gt;&gt; x_max = ivy.Container(a=1, b=-1)</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_roll(x, x_min, x_max)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 1., 1.]),</span>
<span class="sd">        b: ivy.array([-1., -1., -1.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="clip"><a class="viewcode-back" href="../../../container/container_methods/clip.html#ivy.container.container_methods.clip">[docs]</a><span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.clip. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.clip also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container containing elements to clip.</span>
<span class="sd">    x_min</span>
<span class="sd">        Minimum value.</span>
<span class="sd">    x_max</span>
<span class="sd">        Maximum value.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container with the elements of x, but where values &lt; x_min are replaced</span>
<span class="sd">        with x_min, and those &gt; x_max with x_max.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 2.]), b=ivy.array([3., 4., 5.]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.clip(1,2)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1., 1., 2.]),</span>
<span class="sd">        b: ivy.array([2., 2., 2.])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.norms</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="layer_norm"><a class="viewcode-back" href="../../../container/container_methods/layer_norm.html#ivy.container.container_methods.layer_norm">[docs]</a><span class="k">def</span> <span class="nf">layer_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">normalized_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">_MIN_BASE</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">new_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.layer_norm. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.layer_norm also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container</span>
<span class="sd">    normalized_idxs</span>
<span class="sd">        Indices to apply the normalization to.</span>
<span class="sd">    epsilon</span>
<span class="sd">        small constant to add to the denominator, use global ivy._MIN_BASE by</span>
<span class="sd">        default.</span>
<span class="sd">    scale</span>
<span class="sd">        Learnable gamma variables for post-multiplication, default is None.</span>
<span class="sd">    offset</span>
<span class="sd">        Learnable beta variables for post-addition, default is None.</span>
<span class="sd">    new_std</span>
<span class="sd">        The standard deviation of the new normalized values. Default is 1.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        The layer after applying layer normalization.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: ivy.array([7., 10., 12.]), \</span>
<span class="sd">                           &#39;b&#39;: ivy.array([[1., 2., 3.], [4., 5., 6.]])})</span>
<span class="sd">    &gt;&gt;&gt; normalized_idxs = [0]</span>
<span class="sd">    &gt;&gt;&gt; norm = x.layer_norm(normalized_idxs, epsilon=1.25, scale=0.3)</span>
<span class="sd">    &gt;&gt;&gt; print(norm)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.658, 1.04, 1.3]),</span>
<span class="sd">        b: ivy.array([[0.759, 0.759, 0.759], </span>
<span class="sd">                      [1.24, 1.24, 1.24]])</span>
<span class="sd">    }</span>

<span class="sd">    With multiple :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container({&#39;a&#39;: ivy.array([7., 10., 12.]), \</span>
<span class="sd">                           &#39;b&#39;: ivy.array([[1., 2., 3.], [4., 5., 6.]])})</span>
<span class="sd">    &gt;&gt;&gt; normalized_idxs = ivy.Container({&#39;a&#39;: [0], &#39;b&#39;: [1]})</span>
<span class="sd">    &gt;&gt;&gt; new_std = ivy.Container({&#39;a&#39;: 1.25, &#39;b&#39;: 1.5})</span>
<span class="sd">    &gt;&gt;&gt; offset = ivy.Container({&#39;a&#39;: 0.2, &#39;b&#39;: 0.3})</span>
<span class="sd">    &gt;&gt;&gt; norm = x.layer_norm(normalized_idxs, new_std=new_std, offset=offset)</span>
<span class="sd">    &gt;&gt;&gt; print(norm)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-1.42, 0.403, 1.62]),</span>
<span class="sd">        b: ivy.array([[-1.54, 0.3, 2.14], </span>
<span class="sd">                      [-1.54, 0.3, 2.14]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.random</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_random_uniform"><a class="viewcode-back" href="../../../container/container_methods/static_random_uniform.html#ivy.container.container_methods.static_random_uniform">[docs]</a><span class="k">def</span> <span class="nf">static_random_uniform</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">low</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.random_uniform. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_uniform also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low</span>
<span class="sd">        Lower boundary of the output interval. All values generated will be</span>
<span class="sd">        greater than or equal to ``low``. If array, must have same shape as</span>
<span class="sd">        ``high``.</span>
<span class="sd">    high</span>
<span class="sd">        Upper boundary of the output interval. All the values generated will be</span>
<span class="sd">        less than ``high``. If array, must have same shape as ``low``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized uniform distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]), \</span>
<span class="sd">                          b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]), \</span>
<span class="sd">                          b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_uniform(low=x, high=y, device=&#39;cpu&#39;, \</span>
<span class="sd">                                            dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.8, 23.7],</span>
<span class="sd">                      [17., 16.6]]),</span>
<span class="sd">        b: ivy.array([[2.35, 3.69],</span>
<span class="sd">                      [17.4, 48.]])</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Array` and :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.0,-9.0,-3.4])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_uniform(low=x, high=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.481, -8.03, -2.74]),</span>
<span class="sd">        b: ivy.array([0.0999, -7.38, -1.29])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="random_uniform"><a class="viewcode-back" href="../../../container/container_methods/random_uniform.html#ivy.container.container_methods.random_uniform">[docs]</a><span class="k">def</span> <span class="nf">random_uniform</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.random_uniform. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_uniform also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lower boundary of the output interval. All values generated will be</span>
<span class="sd">        greater than or equal to ``low``. If array, must have same shape as</span>
<span class="sd">        ``high``.</span>
<span class="sd">    high</span>
<span class="sd">        Upper boundary of the output interval. All the values generated will be</span>
<span class="sd">        less than ``high``. If array, must have same shape as ``low``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized uniform distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7.5,6.7,0.9]), b=ivy.array([8.7,9.8,4.5]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=17.4)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([11.2, 10.5, 13.1]),</span>
<span class="sd">        b: ivy.array([11.2, 11.9, 6.01])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.55, 10.1, 4.08]),</span>
<span class="sd">        b: ivy.array([9.45, 9.9, 8.6])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12.4, 11.7, 7.25]),</span>
<span class="sd">        b: ivy.array([11.8, 11.8, 4.96])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.86, 9.24, 6.43]),</span>
<span class="sd">        b: ivy.array([8.95, 10.1, 8.51])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9.6, 8.24, 3.67]),</span>
<span class="sd">        b: ivy.array([9.29, 11.2, 9.84])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=10.4, b=17.4)</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.24, 9.22, 1.52]),</span>
<span class="sd">        b: ivy.array([16.5, 13.4, 17.3])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.55, 10.1, 4.08]),</span>
<span class="sd">        b: ivy.array([9.45, 9.9, 8.6])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([12.4, 11.7, 7.25]),</span>
<span class="sd">        b: ivy.array([11.8, 11.8, 4.96])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.86, 9.24, 6.43]),</span>
<span class="sd">        b: ivy.array([8.95, 10.1, 8.51])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9.6, 8.24, 3.67]),</span>
<span class="sd">        b: ivy.array([9.29, 11.2, 9.84])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]), \</span>
<span class="sd">                          b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]), \</span>
<span class="sd">                          b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.4, 17.],</span>
<span class="sd">                      [9.81, 10.9]]),</span>
<span class="sd">        b: ivy.array([[3.6, 4.31],</span>
<span class="sd">                      [18.8, 54.2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.1, 7.93],</span>
<span class="sd">                      [7.98, 6.]]),</span>
<span class="sd">        b: ivy.array([[4.28, 4.65],</span>
<span class="sd">                      [13.9, 28.9]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.6, 28.],</span>
<span class="sd">                      [16.4, 4.92]]),</span>
<span class="sd">        b: ivy.array([[3.61, 4.82],</span>
<span class="sd">                      [12.6, 10.2]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.7, 28.4],</span>
<span class="sd">                      [9.29, 17.4]]),</span>
<span class="sd">        b: ivy.array([[1.88, 4.94],</span>
<span class="sd">                      [17., 9.68]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((2,2)), b=ivy.ones((2,2)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_uniform(high=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.4, 29.8],</span>
<span class="sd">                      [12.1, 3.9]]),</span>
<span class="sd">        b: ivy.array([[3.79, 5.4],</span>
<span class="sd">                      [16.2, 31.7]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_random_normal"><a class="viewcode-back" href="../../../container/container_methods/static_random_normal.html#ivy.container.container_methods.static_random_normal">[docs]</a><span class="k">def</span> <span class="nf">static_random_normal</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mean</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">std</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.random_normal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_normal</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mean</span>
<span class="sd">        The mean of the normal distribution to sample from. Default is ``0.0``.</span>
<span class="sd">    std</span>
<span class="sd">        The standard deviation of the normal distribution to sample from.</span>
<span class="sd">        Must be non-negative. Default is ``1.0``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``mean`` and ``std`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]), \</span>
<span class="sd">                          b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]), \</span>
<span class="sd">                          b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_normal(mean=x, std=y, device=&#39;cpu&#39;, \</span>
<span class="sd">                                           dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[-4.11, 0.651],</span>
<span class="sd">                      [19.3, -30.4]]),</span>
<span class="sd">        b: ivy.array([[1.15, 3.39],</span>
<span class="sd">                      [-9.35, -13.9]])</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Array` and :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1.0,-9.0,-3.4])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0.6, 0.2, 0.3]),b=ivy.array([0.8, 0.2, 0.2]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_random_normal(mean=x, std=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-0.651, -9.25, -3.54]),</span>
<span class="sd">        b: ivy.array([0.464, -8.51, -3.75])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="random_normal"><a class="viewcode-back" href="../../../container/container_methods/random_normal.html#ivy.container.container_methods.random_normal">[docs]</a><span class="k">def</span> <span class="nf">random_normal</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">std</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.random_normal. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.random_normal also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The mean of the normal distribution to sample from. Default is ``0.0``.</span>
<span class="sd">    std</span>
<span class="sd">        The standard deviation of the normal distribution to sample from.</span>
<span class="sd">        Must be non-negative. Default is ``1.0``.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``mean`` and ``std`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default floating-point data type. Default ``None``</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7.5,6.7,0.9]), \</span>
<span class="sd">                          b=ivy.array([8.7,9.8,4.5]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=17.4)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([11.9, -22.9, -24.8]),</span>
<span class="sd">        b: ivy.array([44.3, -21.6, 2.03])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.2, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7.82, 6.21, -0.431]),</span>
<span class="sd">        b: ivy.array([13.8, 9.9, 7.64])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=14.2, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-18.3, -3.42, 9.55]),</span>
<span class="sd">        b: ivy.array([-1.31, 7.68, -6.93])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=10.8, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([13.4, -3.14, 10.7]),</span>
<span class="sd">        b: ivy.array([11.7, 4.85, 5.83])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=11.2, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-6.84, 0.274, 14.2]),</span>
<span class="sd">        b: ivy.array([29.1, 7.19, 3.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=10.4, b=17.4)</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([-9.5, 8.54, -9.13]),</span>
<span class="sd">        b: ivy.array([-24.5, 18.9, 11.])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.47, 8.23, 8.69]),</span>
<span class="sd">        b: ivy.array([10.7, 16.2, 16.1])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([8.22, -15.9, 10.4]),</span>
<span class="sd">        b: ivy.array([19.9, 11.5, -2.15])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([19.6, -4.08, 6.09]),</span>
<span class="sd">        b: ivy.array([-23.9, 6.86, 17.6])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([14.7, 8.99, 8.46]),</span>
<span class="sd">        b: ivy.array([22.9, -5.97, -1.28])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9.8,7.6],[6.5,2.3]]), \</span>
<span class="sd">                          b=ivy.array([[0.9,2.4],[7.6,5.4]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10.9,32.4],[18.7,19.6]]), \</span>
<span class="sd">                          b=ivy.array([[4.3,5.6],[23.4,54.3]]))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[10.6, 7.89],</span>
<span class="sd">                      [9.39, 19.4]]),</span>
<span class="sd">        b: ivy.array([[3.76, 4.68],</span>
<span class="sd">                      [17.7, 24.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[30.9, 24.6],</span>
<span class="sd">                      [29.9, -25.3]]),</span>
<span class="sd">        b: ivy.array([[8.02, 1.92],</span>
<span class="sd">                      [-5.34, -54.1]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, dtype=&#39;float16&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[7.82, -35.],</span>
<span class="sd">                      [11.7, 0.696]]),</span>
<span class="sd">        b: ivy.array([[-4.07, -2.91],</span>
<span class="sd">                      [19.2, 46.8]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[25.4, 28.3],</span>
<span class="sd">                      [19.6, -9.83]]),</span>
<span class="sd">        b: ivy.array([[2.95, 2.48],</span>
<span class="sd">                      [-30.8, -40.1]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((2,2)), b=ivy.ones((2,2)))</span>
<span class="sd">    &gt;&gt;&gt; x.random_normal(std=y, device=&#39;cpu&#39;, dtype=&#39;float64&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[2.8, -45.6],</span>
<span class="sd">                      [-10.4, 0.65]]),</span>
<span class="sd">        b: ivy.array([[3.8, 1.43],</span>
<span class="sd">                      [23., 29.4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_multinomial"><a class="viewcode-back" href="../../../container/container_methods/static_multinomial.html#ivy.container.container_methods.static_multinomial">[docs]</a><span class="k">def</span> <span class="nf">static_multinomial</span><span class="p">(</span>
    <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">probs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.multinomial. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.multinomial also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    population_size</span>
<span class="sd">        The size of the population from which to draw samples.</span>
<span class="sd">    num_samples</span>
<span class="sd">        Number of independent samples to draw from the population.</span>
<span class="sd">    batch_size</span>
<span class="sd">        Number of tensors to generate. Default is 1.</span>
<span class="sd">    probs</span>
<span class="sd">        The unnormalized probabilities for all elements in population,</span>
<span class="sd">        default is uniform *[batch_shape, population_size]*</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace samples once they&#39;ve been drawn. Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="multinomial"><a class="viewcode-back" href="../../../container/container_methods/multinomial.html#ivy.container.container_methods.multinomial">[docs]</a><span class="k">def</span> <span class="nf">multinomial</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">population_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.multinomial. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.multinomial also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        The unnormalized probabilities for all elements in population,</span>
<span class="sd">        default is uniform *[batch_shape, population_size]*</span>
<span class="sd">    population_size</span>
<span class="sd">        The size of the population from which to draw samples.</span>
<span class="sd">    num_samples</span>
<span class="sd">        Number of independent samples to draw from the population.</span>
<span class="sd">    batch_size</span>
<span class="sd">        Number of tensors to generate. Default is 1.</span>
<span class="sd">    replace</span>
<span class="sd">        Whether to replace samples once they&#39;ve been drawn. Default is True.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None)</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Drawn samples from the parameterized normal distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_randint"><a class="viewcode-back" href="../../../container/container_methods/static_randint.html#ivy.container.container_methods.static_randint">[docs]</a><span class="k">def</span> <span class="nf">static_randint</span><span class="p">(</span>
    <span class="n">low</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.randint. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.randint also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low</span>
<span class="sd">        Lowest integer that can be drawn from the distribution.</span>
<span class="sd">    high</span>
<span class="sd">        One above the highest integer that can be drawn from the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default integer data type. Default ``None``</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array with the given shape filled with integers from</span>
<span class="sd">        the uniform distribution in the half-open interval [low, high)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9,7],[6,2]]), \</span>
<span class="sd">                          b=ivy.array([[0,2],[10,6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10,32],[18,19]]), \</span>
<span class="sd">                          b=ivy.array([[44,5],[23,54]]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_randint(x, y, device=&#39;cpu&#39;, dtype=&#39;int32&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 27],</span>
<span class="sd">                      [16, 17]]),</span>
<span class="sd">        b: ivy.array([[13, 3],</span>
<span class="sd">                      [16, 19]])</span>
<span class="sd">    }</span>

<span class="sd">    With a mix of :code:`ivy.Array` and :code:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.array([-1,-9,3])</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([4,7,9]),b=ivy.array([14,17,34]))</span>
<span class="sd">    &gt;&gt;&gt; ivy.Container.static_randint(x, y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([1, 6, 5]),</span>
<span class="sd">        b: ivy.array([0, 10, 17])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="randint"><a class="viewcode-back" href="../../../container/container_methods/randint.html#ivy.container.container_methods.randint">[docs]</a><span class="k">def</span> <span class="nf">randint</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">high</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Shape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeShape</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDevice</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.randint. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.randint also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Lowest integer that can be drawn from the distribution.</span>
<span class="sd">    high</span>
<span class="sd">        One above the highest integer that can be drawn from the distribution.</span>
<span class="sd">    shape</span>
<span class="sd">        If the given shape is, e.g ``(m, n, k)``, then ``m * n * k`` samples</span>
<span class="sd">        are drawn. Can only be specified when ``low`` and ``high`` are numeric</span>
<span class="sd">        values, else exception will be raised.</span>
<span class="sd">        Default is ``None``, where a single value is returned.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    device</span>
<span class="sd">        device on which to create the array &#39;cuda:0&#39;, &#39;cuda:1&#39;, &#39;cpu&#39; etc.</span>
<span class="sd">        (Default value = None).</span>
<span class="sd">    dtype</span>
<span class="sd">         output array data type. If ``dtype`` is ``None``, the output array data</span>
<span class="sd">         type will be the default integer data type. Default ``None``</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        Returns an array with the given shape filled with integers from</span>
<span class="sd">        the uniform distribution in the half-open interval [low, high)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7,6,0]), \</span>
<span class="sd">                          b=ivy.array([8,9,4]))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(30)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([23, 15, 20]),</span>
<span class="sd">        b: ivy.array([28, 22, 18])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(10, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9, 7, 7]),</span>
<span class="sd">        b: ivy.array([8, 9, 9])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(102, dtype=&#39;int8&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([9, 8, 2]),</span>
<span class="sd">        b: ivy.array([62, 62, 60])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(54, device=&#39;cpu&#39;, dtype=&#39;int64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([30, 29, 26]),</span>
<span class="sd">        b: ivy.array([24, 24, 21])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(21, device=&#39;cpu&#39;, dtype=&#39;int8&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=54, b=17)</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, dtype=&#39;int64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int32&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((3,)), b=ivy.ones((3,)))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int16&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([7, 6, 0]),</span>
<span class="sd">        b: ivy.array([8, 9, 4])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[9,7],[6,2]]), \</span>
<span class="sd">                          b=ivy.array([[0,2],[10,6]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([[10,32],[18,19]]), \</span>
<span class="sd">                          b=ivy.array([[44,5],[23,54]]))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, dtype=&#39;int64&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int32&#39;)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; z = ivy.Container(a=ivy.zeros((2,2)), b=ivy.ones((2,2)))</span>
<span class="sd">    &gt;&gt;&gt; x.randint(y, device=&#39;cpu&#39;, dtype=&#39;int16&#39;, out=z)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([[9, 7],</span>
<span class="sd">                      [6, 2]]),</span>
<span class="sd">        b: ivy.array([[0, 2],</span>
<span class="sd">                      [10, 6]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_shuffle"><a class="viewcode-back" href="../../../container/container_methods/static_shuffle.html#ivy.container.container_methods.static_shuffle">[docs]</a><span class="k">def</span> <span class="nf">static_shuffle</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container static method variant of ivy.shuffle. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.shuffle also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        Input array or container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container object, shuffled along the first dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="shuffle"><a class="viewcode-back" href="../../../container/container_methods/shuffle.html#ivy.container.container_methods.shuffle">[docs]</a><span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;ivy.Container instance method variant of ivy.shuffle. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.shuffle also</span>
<span class="sd">    applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        Input container. Should have a numeric data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        A container object, shuffled along the first dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.searching</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_argmax"><a class="viewcode-back" href="../../../container/container_methods/static_argmax.html#ivy.container.container_methods.static_argmax">[docs]</a><span class="k">def</span> <span class="nf">static_argmax</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.argmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmax also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the maximum value of the flattened array. Default  None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the array.</span>
<span class="sd">    out</span>
<span class="sd">        If provided, the result will be inserted into this array. It should be of</span>
<span class="sd">        the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the maximum values across the</span>
<span class="sd">        specified axis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../container/container_methods/argmax.html#ivy.container.container_methods.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argmax. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmax also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the maximum value of the flattened array. Default  None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will broadcast</span>
<span class="sd">        correctly against the array.</span>
<span class="sd">    out</span>
<span class="sd">        If provided, the result will be inserted into this array. It should be of</span>
<span class="sd">        the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the maximum values across the</span>
<span class="sd">        specified axis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_argmin"><a class="viewcode-back" href="../../../container/container_methods/static_argmin.html#ivy.container.container_methods.static_argmin">[docs]</a><span class="k">def</span> <span class="nf">static_argmin</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.argmin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmin also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the minimum value of the flattened array. Default = None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see Broadcasting). Otherwise, if False, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default = False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the minimum values across the</span>
<span class="sd">        specified axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../container/container_methods/argmin.html#ivy.container.container_methods.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argmin. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.argmin also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to search. If None, the function must return the index of</span>
<span class="sd">        the minimum value of the flattened array. Default = None.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see Broadcasting). Otherwise, if False, the reduced axes</span>
<span class="sd">        (dimensions) must not be included in the result. Default = False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the minimum values across the</span>
<span class="sd">        specified axis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_nonzero"><a class="viewcode-back" href="../../../container/container_methods/static_nonzero.html#ivy.container.container_methods.static_nonzero">[docs]</a><span class="k">def</span> <span class="nf">static_nonzero</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nonzero also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the nonzero values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="nonzero"><a class="viewcode-back" href="../../../container/container_methods/nonzero.html#ivy.container.container_methods.nonzero">[docs]</a><span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.nonzero. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.nonzero also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the indices of the nonzero values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_where"><a class="viewcode-back" href="../../../container/container_methods/static_where.html#ivy.container.container_methods.static_where">[docs]</a><span class="k">def</span> <span class="nf">static_where</span><span class="p">(</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.where. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.where also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the values of x1 where condition is True, and x2</span>
<span class="sd">        where condition is False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../../container/container_methods/where.html#ivy.container.container_methods.where">[docs]</a><span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="n">x2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.where. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.where also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array or container. Should have a boolean data type.</span>
<span class="sd">    x1</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    x2</span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container containing the values of x1 where condition is True, and x2</span>
<span class="sd">        where condition is False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.set</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>


<div class="viewcode-block" id="static_unique_all"><a class="viewcode-back" href="../../../container/container_methods/static_unique_all.html#ivy.container.container_methods.static_unique_all">[docs]</a><span class="k">def</span> <span class="nf">static_unique_all</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="unique_all"><a class="viewcode-back" href="../../../container/container_methods/unique_all.html#ivy.container.container_methods.unique_all">[docs]</a><span class="k">def</span> <span class="nf">unique_all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_unique_counts"><a class="viewcode-back" href="../../../container/container_methods/static_unique_counts.html#ivy.container.container_methods.static_unique_counts">[docs]</a><span class="k">def</span> <span class="nf">static_unique_counts</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.unique_counts. This method simply </span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_counts also applies </span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container. If ``x`` has more than one dimension, the function must</span>
<span class="sd">        flatten ``x`` and return the unique elements of the flattened array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, counts)`` whose</span>

<span class="sd">        - first element must have the field name ``values`` and must be an</span>
<span class="sd">        array containing the unique elements of ``x``.</span>
<span class="sd">        The array must have the same data type as ``x``.</span>
<span class="sd">        - second element must have the field name ``counts`` and must be an array</span>
<span class="sd">        containing the number of times each unique element occurs in ``x``.</span>
<span class="sd">        The returned array must have same shape as ``values`` and must</span>
<span class="sd">        have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 3. , 2. , 1. , 0.]), \</span>
<span class="sd">                          b=ivy.array([1,2,1,3,4,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.static_unique_counts(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (list[2],&lt;classivy.array.Array&gt;shape=[4]),</span>
<span class="sd">        b: (list[2],&lt;classivy.array.Array&gt;shape=[4])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="unique_counts"><a class="viewcode-back" href="../../../container/container_methods/unique_counts.html#ivy.container.container_methods.unique_counts">[docs]</a><span class="k">def</span> <span class="nf">unique_counts</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.unique_counts. This method</span>
<span class="sd">    simply wraps the function, and so the docstring for ivy.unique_counts</span>
<span class="sd">    also applies to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. If ``x`` has more than one dimension, the function must</span>
<span class="sd">        flatten ``x`` and return the unique elements of the flattened array.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a namedtuple ``(values, counts)`` whose</span>

<span class="sd">        - first element must have the field name ``values`` and must be an</span>
<span class="sd">        array containing the unique elements of ``x``.</span>
<span class="sd">        The array must have the same data type as ``x``.</span>
<span class="sd">        - second element must have the field name ``counts`` and must be an array</span>
<span class="sd">        containing the number of times each unique element occurs in ``x``.</span>
<span class="sd">        The returned array must have same shape as ``values`` and must</span>
<span class="sd">        have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With :code:`ivy.Container` instance method:</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0., 1., 3. , 2. , 1. , 0.]), \</span>
<span class="sd">                          b=ivy.array([1,2,1,3,4,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_counts()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: (list[2],&lt;classivy.array.array.Array&gt;shape=[4]),</span>
<span class="sd">        b: (list[2],&lt;classivy.array.array.Array&gt;shape=[4])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_unique_values"><a class="viewcode-back" href="../../../container/container_methods/static_unique_values.html#ivy.container.container_methods.static_unique_values">[docs]</a><span class="k">def</span> <span class="nf">static_unique_values</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="unique_values"><a class="viewcode-back" href="../../../container/container_methods/unique_values.html#ivy.container.container_methods.unique_values">[docs]</a><span class="k">def</span> <span class="nf">unique_values</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_unique_inverse"><a class="viewcode-back" href="../../../container/container_methods/static_unique_inverse.html#ivy.container.container_methods.static_unique_inverse">[docs]</a><span class="k">def</span> <span class="nf">static_unique_inverse</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="unique_inverse"><a class="viewcode-back" href="../../../container/container_methods/unique_inverse.html#ivy.container.container_methods.unique_inverse">[docs]</a><span class="k">def</span> <span class="nf">unique_inverse</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.unique_inverse. This method simply</span>
<span class="sd">    wraps the function, and so the docstring for ivy.unique_inverse also applies</span>
<span class="sd">    to this method with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">         input container. If ``x`` has more than one dimension, the function must</span>
<span class="sd">         flatten ``x`` and return the unique elements of the flattened array.</span>
<span class="sd">    key_chains</span>
<span class="sd">         The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">         If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">         will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">         Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">         Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">         Whether to also map method to sequences (lists, tuples). Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>

<span class="sd">         a namedtuple ``(values, inverse_indices)`` whose</span>

<span class="sd">         - first element must have the field name ``values`` and must be an array</span>
<span class="sd">         containing the unique elements of ``x``. The array must have the same data</span>
<span class="sd">         type as ``x``.</span>
<span class="sd">         - second element must have the field name ``inverse_indices`` and</span>
<span class="sd">          must be an array containing the indices of ``values`` that</span>
<span class="sd">          reconstruct ``x``. The array must have the same shape as ``x`` and</span>
<span class="sd">          must have the default array index data type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([4.,8.,3.,5.,9.,4.]),\</span>
<span class="sd">    ... b=ivy.array([7,6,4,5,6,3,2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.unique_inverse()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">         {</span>
<span class="sd">           a: (list[2], &lt;class ivy.array.array.Array&gt; shape=[5]),</span>
<span class="sd">           b: (list[2], &lt;class ivy.array.array.Array&gt; shape=[6])</span>
<span class="sd">         }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.sorting</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># local</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_argsort"><a class="viewcode-back" href="../../../container/container_methods/static_argsort.html#ivy.container.container_methods.static_argsort">[docs]</a><span class="k">def</span> <span class="nf">static_argsort</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argsort. This method </span>
<span class="sd">    simply wraps the function, and so the docstring for </span>
<span class="sd">    ivy.argsort also applies to this method with minimal changes.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x </span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to sort. If set to ``-1``, the function must sort </span>
<span class="sd">        along the last axis. Default: ``-1``.</span>
<span class="sd">    descending</span>
<span class="sd">        sort order. If ``True``, the returned indices sort</span>
<span class="sd">        ``x`` in descending order (by value). If ``False``, </span>
<span class="sd">        the returned indices sort ``x`` in ascending order </span>
<span class="sd">        (by value). Default: ``False``.</span>
<span class="sd">    stable</span>
<span class="sd">        sort stability. If ``True``, the returned indices must maintain</span>
<span class="sd">        the relative order of ``x`` values which compare as equal.</span>
<span class="sd">        If ``False``, the returned indices may or may not maintain</span>
<span class="sd">        the relative order of ``x`` values which compare as equal (i.e., the </span>
<span class="sd">        relative order of ``x`` values which compare as equal </span>
<span class="sd">        is implementation-dependent). Default: ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret </span>
<span class="sd">        a container containing the index values of sorted</span>
<span class="sd">        array. The returned array must have a</span>
<span class="sd">        data type determined by :ref:`type-promotion`.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With: code:`ivy.Container` inputs:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7, 2, 1]),\</span>
<span class="sd">                          b=ivy.array([3, 2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 2]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7, 2, 1]),\</span>
<span class="sd">                          b=ivy.array([[3, 2], [7, 0.2]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 2]),</span>
<span class="sd">        b: ivy.array([[0, 1]],[0, 1]])</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    With: code:`ivy.Container` inputs:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([2, 5, 1]),\</span>
<span class="sd">                          b=ivy.array([1, 5], [.2,.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 0, 1]),</span>
<span class="sd">        b: ivy.array([[1, 0],\</span>
<span class="sd">                        [0,1]])</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.native_array([2, 5, 1]),\</span>
<span class="sd">                          b=ivy.array([1, 5], [.2,.1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.static_argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2, 0, 1]),</span>
<span class="sd">        b: ivy.array([[1, 0],\</span>
<span class="sd">                        [0,1]])</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../../container/container_methods/argsort.html#ivy.container.container_methods.argsort">[docs]</a><span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.argsort.</span>
<span class="sd">    This method simply wraps the function, and </span>
<span class="sd">    so the docstring for ivy.argsort also applies to this method</span>
<span class="sd">    with minimal changes.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self </span>
<span class="sd">        input array or container. Should have a numeric data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis along which to sort. If set to ``-1``, the function </span>
<span class="sd">        must sort along the last axis. Default: ``-1``.</span>
<span class="sd">    descending</span>
<span class="sd">        sort order. If ``True``, the returned indices sort ``x``</span>
<span class="sd">        in descending order (by value). If ``False``, the </span>
<span class="sd">        returned indices sort ``x`` in ascending order (by value).</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    stable</span>
<span class="sd">        sort stability. If ``True``, the returned indices must</span>
<span class="sd">        maintain the relative order of ``x`` values which compare</span>
<span class="sd">        as equal. If ``False``, the returned indices may or may not</span>
<span class="sd">        maintain the relative order of ``x`` values which compare </span>
<span class="sd">        as equal (i.e., the relative order of ``x`` values which </span>
<span class="sd">        compare as equal is implementation-dependent).</span>
<span class="sd">        Default: ``True``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). </span>
<span class="sd">        Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret </span>
<span class="sd">        a container containing the index values of sorted array.</span>
<span class="sd">        The returned array must have a data type determined </span>
<span class="sd">        by :ref:`type-promotion`.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([7, 2, 1]),\</span>
<span class="sd">                          b=ivy.array([3, 2]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.argsort(axis=-1, descending=True, stable=False)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0, 1, 2]),</span>
<span class="sd">        b: ivy.array([0, 1])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_sort"><a class="viewcode-back" href="../../../container/container_methods/static_sort.html#ivy.container.container_methods.static_sort">[docs]</a><span class="k">def</span> <span class="nf">static_sort</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.sort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.add also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    With one :code:`ivy.Container` input:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5, 9, 0.2]),\</span>
<span class="sd">                          b=ivy.array([[8, 1], [5, 0.8]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.2, 5., 9.]),</span>
<span class="sd">        b: ivy.array([[1., 8.], [0.8, 5.]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([8, 0.5, 6]),\</span>
<span class="sd">                          b=ivy.array([[9, 0.7], [0.4, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 6., 8.]),</span>
<span class="sd">        b: ivy.array([[0.7, 9.], [0., 0.4]])</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../container/container_methods/sort.html#ivy.container.container_methods.sort">[docs]</a><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">descending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">stable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.sort. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.sort also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Withcode:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5, 9, 0.2]),\</span>
<span class="sd">                          b=ivy.array([8, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.2, 5., 9.]),</span>
<span class="sd">        b: ivy.array([1, 8])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([5, 9, 0.2]), \</span>
<span class="sd">                          b=ivy.array([[8, 1], [5, 0.8]]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.sort()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    { a: ivy.array([0.2, 5., 9.]), \</span>
<span class="sd">      b: ivy.array([[1., 8.],[0.8, 5.]])</span>
<span class="sd">    }</span>

<span class="sd">    Withcode:`ivy.Container` inputs:</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([8, 0.5, 6]),\</span>
<span class="sd">                          b=ivy.array([[9, 0.7], [0.4, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 6., 8.]),</span>
<span class="sd">        b: ivy.array([[0.7, 9.],\</span>
<span class="sd">                        [0., 0.4]])</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.native_array([8, 0.5, 6]),\</span>
<span class="sd">                          b=ivy.array([[9, 0.7], [0.4, 0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.sort(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([0.5, 6., 8.]),</span>
<span class="sd">        b: ivy.array([[0.7, 9.],</span>
<span class="sd">              [0., 0.4]])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_searchsorted"><a class="viewcode-back" href="../../../container/container_methods/static_searchsorted.html#ivy.container.container_methods.static_searchsorted">[docs]</a><span class="k">def</span> <span class="nf">static_searchsorted</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="searchsorted"><a class="viewcode-back" href="../../../container/container_methods/searchsorted.html#ivy.container.container_methods.searchsorted">[docs]</a><span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.statistical</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>

<span class="c1"># ToDo: implement all methods here as public instance methods</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../container/container_methods/min.html#ivy.container.container_methods.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../container/container_methods/max.html#ivy.container.container_methods.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="mean"><a class="viewcode-back" href="../../../container/container_methods/mean.html#ivy.container.container_methods.mean">[docs]</a><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="var"><a class="viewcode-back" href="../../../container/container_methods/var.html#ivy.container.container_methods.var">[docs]</a><span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.var.</span>
<span class="sd">    This method simply wraps the function, and so the</span>
<span class="sd">    docstring for ivy.var also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container. Should have a floating-point data type.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which variances must be computed. By default, the</span>
<span class="sd">        variance must be computed over the entire array for each array in the input</span>
<span class="sd">        container. If a tuple of integers, variances must be computed over</span>
<span class="sd">        multiple axes. Default: None.</span>
<span class="sd">    correction</span>
<span class="sd">        degrees of freedom adjustment. Setting this parameter to a value other than</span>
<span class="sd">        0 has the effect of adjusting the divisor during the calculation of the</span>
<span class="sd">        variance according to N-c where N corresponds to the total number of</span>
<span class="sd">        elements over which the variance is computed and c corresponds to the</span>
<span class="sd">        provided degrees of freedom adjustment. When computing the variance of a</span>
<span class="sd">        population, setting this parameter to 0 is the standard choice (i.e.,</span>
<span class="sd">        the provided array contains data constituting an entire population).</span>
<span class="sd">        When computing the unbiased sample variance, setting this parameter to 1</span>
<span class="sd">        is the standard choice (i.e., the provided array contains data sampled from</span>
<span class="sd">        a larger population; this is commonly referred to as Bessel&#39;s correction).</span>
<span class="sd">        Default: 0.</span>
<span class="sd">    keepdims</span>
<span class="sd">        if True, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible</span>
<span class="sd">        with the input array (see Broadcasting). Otherwise, if False, the</span>
<span class="sd">        reduced axes (dimensions) must not be included in the result.</span>
<span class="sd">        Default: False.</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not</span>
<span class="sd">        applied. Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to. It must have a</span>
<span class="sd">        shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        a container contianing different arrays depends on parameters. see below</span>
<span class="sd">        for the types of arrays in the returned container if the variance was</span>
<span class="sd">        computed over the entire array, a zero-dimensional array containing the</span>
<span class="sd">        variance; otherwise, a non-zero-dimensional array containing the variances.</span>
<span class="sd">        The returned container must have the same data type as self.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, 1.0, 2.0]), \</span>
<span class="sd">    b=ivy.array([3.0, 4.0, 5.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.var()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0.6666667),</span>
<span class="sd">        b: ivy.array(0.6666667)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.0, 1.0, 2.0]), \</span>
<span class="sd">    b=ivy.array([3.0, 4.0, 5.0]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array(0.), b=ivy.array(0.))</span>
<span class="sd">    &gt;&gt;&gt; x.var(out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(0.6666667),</span>
<span class="sd">        b: ivy.array(0.6666667)</span>
<span class="sd">    }</span>

<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0]]), \</span>
<span class="sd">                          b=ivy.array([[6.0, 7.0, 8.0], [9.0, 10.0, 11.0]]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container(a=ivy.array([0., 0., 0.]), b=ivy.array([0., 0., 0.]))</span>
<span class="sd">    &gt;&gt;&gt; x.var(axis=0, out=y)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array([2.25, 2.25, 2.25]),</span>
<span class="sd">        b: ivy.array([2.25, 2.25, 2.25])</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_var"><a class="viewcode-back" href="../../../container/container_methods/static_var.html#ivy.container.container_methods.static_var">[docs]</a><span class="k">def</span> <span class="nf">static_var</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.var.</span>
<span class="sd">    This method simply wraps the function, and so</span>
<span class="sd">    the docstring for ivy.var also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input array. Should have a floating-point data type.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains,</span>
<span class="sd">        otherwise key_chains will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was</span>
<span class="sd">        not applied. Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples).</span>
<span class="sd">        Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output, for writing the result to.</span>
<span class="sd">        It must have a shape that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">       if the variance was computed over the entire array,</span>
<span class="sd">       a zero-dimensional array containing the variance;</span>
<span class="sd">       otherwise, a non-zero-dimensional array containing the</span>
<span class="sd">       variances. The returned array must have the same data</span>
<span class="sd">       type as x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0.1, 0.2, 0.9]), \</span>
<span class="sd">                          b=ivy.array([0.7, 0.1, 0.9]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_var(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a:ivy.array(0.12666667),</span>
<span class="sd">        b:ivy.array(0.11555555)</span>
<span class="sd">    }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="prod"><a class="viewcode-back" href="../../../container/container_methods/prod.html#ivy.container.container_methods.prod">[docs]</a><span class="k">def</span> <span class="nf">prod</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../../container/container_methods/sum.html#ivy.container.container_methods.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Dtype</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="std"><a class="viewcode-back" href="../../../container/container_methods/std.html#ivy.container.container_methods.std">[docs]</a><span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">correction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="einsum"><a class="viewcode-back" href="../../../container/container_methods/einsum.html#ivy.container.container_methods.einsum">[docs]</a><span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="n">equation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.utility</span>
<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>
<span class="kn">from</span> <span class="nn">ivy.container.base</span> <span class="kn">import</span> <span class="n">ContainerBase</span>


<span class="c1"># noinspection PyMissingConstructor</span>
<div class="viewcode-block" id="static_all"><a class="viewcode-back" href="../../../container/container_methods/static_all.html#ivy.container.container_methods.static_all">[docs]</a><span class="k">def</span> <span class="nf">static_all</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.all. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical AND reduction. By default, a</span>
<span class="sd">        logical AND reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical AND reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default  ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical AND reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must be a non-zero-dimensional array</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_all(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(False),</span>
<span class="sd">        b: ivy.array(False)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="all"><a class="viewcode-back" href="../../../container/container_methods/all.html#ivy.container.container_methods.all">[docs]</a><span class="k">def</span> <span class="nf">all</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.all. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.all also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical AND reduction. By default, a</span>
<span class="sd">        logical AND reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical AND reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default  ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output container, for writing the result to. It must have a shape</span>
<span class="sd">        that the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical AND reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must have non-zero-dimensional arrays</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.all()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(False),</span>
<span class="sd">        b: ivy.array(False)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="static_any"><a class="viewcode-back" href="../../../container/container_methods/static_any.html#ivy.container.container_methods.static_any">[docs]</a><span class="k">def</span> <span class="nf">static_any</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">NativeArray</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container static method variant of ivy.any. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.any also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical OR reduction. By default, a</span>
<span class="sd">        logical OR reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical OR reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical OR reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must have non-zero-dimensional arrays</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = ivy.Container.static_any(x)</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(True),</span>
<span class="sd">        b: ivy.array(True)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="any"><a class="viewcode-back" href="../../../container/container_methods/any.html#ivy.container.container_methods.any">[docs]</a><span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_chains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">to_apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prune_unapplied</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">map_sequences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ivy.Container instance method variant of ivy.any. This method simply wraps the</span>
<span class="sd">    function, and so the docstring for ivy.any also applies to this method</span>
<span class="sd">    with minimal changes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self</span>
<span class="sd">        input container.</span>
<span class="sd">    axis</span>
<span class="sd">        axis or axes along which to perform a logical OR reduction. By default, a</span>
<span class="sd">        logical OR reduction must be performed over the entire array. If a tuple of</span>
<span class="sd">        integers, logical OR reductions must be performed over multiple axes. A</span>
<span class="sd">        valid ``axis`` must be an integer on the interval ``[-N, N)``, where ``N``</span>
<span class="sd">        is the rank(number of dimensions) of ``self``. If an ``axis`` is specified</span>
<span class="sd">        as a negative integer, the function must determine the axis along which to</span>
<span class="sd">        perform a reduction by counting backward from the last dimension (where</span>
<span class="sd">        ``-1`` refers to the last dimension). If provided an invalid ``axis``, the</span>
<span class="sd">        function must raise an exception. Default: ``None``.</span>
<span class="sd">    keepdims</span>
<span class="sd">        If ``True``, the reduced axes (dimensions) must be included in the result as</span>
<span class="sd">        singleton dimensions, and, accordingly, the result must be compatible with</span>
<span class="sd">        the input array (see :ref:`broadcasting`). Otherwise, if ``False``, the</span>
<span class="sd">        reduced axes(dimensions) must not be included in the result.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    key_chains</span>
<span class="sd">        The key-chains to apply or not apply the method to. Default is None.</span>
<span class="sd">    to_apply</span>
<span class="sd">        If True, the method will be applied to key_chains, otherwise key_chains</span>
<span class="sd">        will be skipped. Default is True.</span>
<span class="sd">    prune_unapplied</span>
<span class="sd">        Whether to prune key_chains for which the function was not applied.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    map_sequences</span>
<span class="sd">        Whether to also map method to sequences (lists, tuples). Default is False.</span>
<span class="sd">    out</span>
<span class="sd">        optional output array, for writing the result to. It must have a shape that</span>
<span class="sd">        the inputs broadcast to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret</span>
<span class="sd">        if a logical OR reduction was performed over the entire array, the returned</span>
<span class="sd">        container must be a zero-dimensional array containing the test result;</span>
<span class="sd">        otherwise, the returned container must have non-zero-dimensional arrays</span>
<span class="sd">        containing the test results. The returned container must have a data type of</span>
<span class="sd">        ``bool``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = ivy.Container(a=ivy.array([0, 1, 2]), b=ivy.array([0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; y = x.any()</span>
<span class="sd">    &gt;&gt;&gt; print(y)</span>
<span class="sd">    {</span>
<span class="sd">        a: ivy.array(True),</span>
<span class="sd">        b: ivy.array(True)</span>
<span class="sd">    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1">#ivy.container.wrapping</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">ivy</span>

<span class="c1"># global</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="n">TO_IGNORE</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;is_variable&quot;</span><span class="p">,</span> <span class="s2">&quot;is_ivy_array&quot;</span><span class="p">,</span> <span class="s2">&quot;is_native_array&quot;</span><span class="p">,</span> <span class="s2">&quot;is_array&quot;</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_wrap_function</span><span class="p">(</span><span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Wraps the function called `function_name`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function_name</span>
<span class="sd">        the name of the function e.g. &quot;abs&quot;, &quot;mean&quot; etc.</span>
<span class="sd">    static</span>
<span class="sd">        whether the function being wrapped will be added as a static method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_function</span>
<span class="sd">        the wrapped function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">new_function</span><span class="p">(</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">key_chains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">to_apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">prune_unapplied</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">map_sequences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">array_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="p">(</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">args</span>
            <span class="ow">and</span> <span class="n">ivy</span><span class="o">.</span><span class="n">is_ivy_container</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">static</span>
        <span class="p">):</span>
            <span class="c1"># if the method has been called as an instance method, and self should not</span>
            <span class="c1"># be the first positional arg, then we need to re-arrange and place self</span>
            <span class="c1"># in the correct location in the args or kwargs</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">]</span>
                <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">ivy</span><span class="o">.</span><span class="n">copy_nest</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">to_mutable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">data_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">data_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">]</span>
                <span class="n">ivy</span><span class="o">.</span><span class="n">insert_into_nest_at_index</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">data_idx</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># return function multi-mapped across the corresponding leaves of the containers</span>
        <span class="k">return</span> <span class="n">ivy</span><span class="o">.</span><span class="n">ContainerBase</span><span class="o">.</span><span class="n">multi_map_in_static_method</span><span class="p">(</span>
            <span class="n">function_name</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">key_chains</span><span class="o">=</span><span class="n">key_chains</span><span class="p">,</span>
            <span class="n">to_apply</span><span class="o">=</span><span class="n">to_apply</span><span class="p">,</span>
            <span class="n">prune_unapplied</span><span class="o">=</span><span class="n">prune_unapplied</span><span class="p">,</span>
            <span class="n">map_sequences</span><span class="o">=</span><span class="n">map_sequences</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">new_function</span>


<div class="viewcode-block" id="add_ivy_container_instance_methods"><a class="viewcode-back" href="../../../container/container_methods/add_ivy_container_instance_methods.html#ivy.container.container_methods.add_ivy_container_instance_methods">[docs]</a><span class="k">def</span> <span class="nf">add_ivy_container_instance_methods</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ivy</span><span class="o">.</span><span class="n">Container</span><span class="p">],</span>
    <span class="n">modules</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ModuleType</span><span class="p">],</span>
    <span class="n">static</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">to_ignore</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loop over all ivy modules such as activations, general, etc. and add</span>
<span class="sd">    the module functions to ivy container as instance methods using _wrap_function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls</span>
<span class="sd">        the class we want to add the instance methods to.</span>
<span class="sd">    modules</span>
<span class="sd">        the modules to loop over: activations, general etc.</span>
<span class="sd">    static</span>
<span class="sd">        whether the function should be added as a static method.</span>
<span class="sd">    to_ignore</span>
<span class="sd">        any functions we don&#39;t want to add an instance method for.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    As shown, `add_ivy_container_instance_methods` adds all the appropriate functions</span>
<span class="sd">    from the statistical module as instance methods to our toy `ContainerExample` class:</span>

<span class="sd">    &gt;&gt;&gt; from ivy.functional.ivy import statistical</span>
<span class="sd">    &gt;&gt;&gt; class ContainerExample: \</span>
<span class="sd">            pass</span>
<span class="sd">    &gt;&gt;&gt; ivy.add_ivy_container_instance_methods(ContainerExample, [statistical])</span>
<span class="sd">    &gt;&gt;&gt; print(hasattr(ContainerExample, &quot;mean&quot;), hasattr(ContainerExample, &quot;var&quot;))</span>
<span class="sd">    True True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">to_ignore</span> <span class="o">=</span> <span class="n">TO_IGNORE</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_ignore</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">full_key</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;static_&quot;</span> <span class="k">if</span> <span class="n">static</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">key</span>
            <span class="c1"># skip cases where the function is protected, or first letter is uppercase</span>
            <span class="c1"># (i.e. is a class), or if the instance method already exists etc</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">full_key</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span>
                <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">full_key</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">full_key</span> <span class="ow">in</span> <span class="n">to_ignore</span>
                <span class="ow">or</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ivy</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">full_key</span><span class="p">,</span> <span class="n">_wrap_function</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">static</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, Ivy Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>